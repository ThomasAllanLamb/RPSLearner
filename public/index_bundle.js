/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("/****** ABOUT ******\n\nArrayMap\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2007.08.19\n\tReleased: \n\tDescription: A map that only takes arrays, but stores them more efficiently than a linear map.\n\t\n\n****** ***** ******/\n\t\nconst Entry = __webpack_require__(4);\n//try using native Map\n//const Map = require(\"./Map.js\");\n\n/******** CONSTRUCTOR ********/\n\nfunction ArrayMap () \n{\n\t//UNF: clone elements? If a person messes with the elements of an array they set to have a value, then discard it and make a fresh one, they will expect .get to return the same value. But since they messed with elements of the array before they got rid of it, the elements of the nodes in this map will have changes and the value the user is looking for will no longer have the same key.\n\tthis._choices = new Map();\n\tthis.size = 0;\n}\n\n\n/******** PROPERTIES ********/\n\n//UNF: recalculate .size at the end of .set\nArrayMap.prototype.size;\n//the next \nArrayMap.prototype._choices;\n//the answer to .get( [] )\nArrayMap.prototype._nodeValue;\nArrayMap.prototype._isOccupied;\n\n\n/******** METHODS ********/\n\nArrayMap.prototype.get = function (key, keyIndex)\n{\n\tkeyIndex = keyIndex || 0;\n\tif (keyIndex == key.length)\n\t{\n\t\treturn this._nodeValue;\n\t}\n\telse\n\t{\n\t\tvar currentElement = key[keyIndex];\n\t\tif (this._choices.has(currentElement))\n\t\t{\n\t\t\tvar nextNode = this._choices.get(currentElement);\n\t\t\tvar nextGet = nextNode.get(key, keyIndex+1);\n\t\t\treturn nextGet;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nArrayMap.prototype.set = function (key, value, keyIndex)\n{\n\tkeyIndex = keyIndex || 0;\n\t\n\tif (keyIndex == key.length)\n\t{\n\t\tthis._nodeValue = value;\n\t\tthis._isOccupied = true;\n\t\tthis._calculateSize();\n\t\treturn value;\n\t}\n\telse\n\t{\n\t\tvar currentElement = key[keyIndex];\n\t\tif (this._choices.has(currentElement))\n\t\t{\n\t\t\tvar nextNode = this._choices.get(currentElement);\n\t\t\t\n\t\t\tnextNode.set(key, value, keyIndex+1);\n\t\t\t\n\t\t\tthis._calculateSize();\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar nextNode = new ArrayMap();\n\t\t\tnextNode.set(key, value, keyIndex+1);\n\t\t\t\n\t\t\tvar currentElement = key[keyIndex];\n\t\t\tthis._choices.set(currentElement, nextNode);\n\t\t\tthis._calculateSize();\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t}\n\t\n}\n\nArrayMap.prototype.has = function (key, keyIndex)\n{\n\tkeyIndex = keyIndex || 0;\n\t\n\tif (keyIndex == key.length)\n\t{\n\t\treturn (this._isOccupied);\n\t}\n\telse\n\t{\n\t\tvar currentElement = key[keyIndex];\n\t\tif (this._choices.has(currentElement))\n\t\t{\n\t\t\tvar nextNode = this._choices.get(currentElement);\n\t\t\treturn nextNode.has(key, keyIndex+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n/* IE 6 does not support __defineGetter__\nMap.prototype.__defineGetter__(\"size\", function () \n{\n\treturn this._data.length;\n});*/\n\nArrayMap.prototype.forEach = function (f, baseKey)\n{\n\tbaseKey = baseKey || new Array();\n\tif (this._isOccupied)\n\t{\n\t\tvar entry = new Entry(baseKey, this._nodeValue);\n\t\tvar result = f(entry);\n\t\tif (result != undefined)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\tif (this._choices.size > 0)\n\t{\n\t\t//!!!inefficient conversion of  to native style\n\t\tthis._choices.forEach(function (value, key, map)\n\t\t\t{\n\t\t\t\tbaseKey.push(entry.key);\n\t\t\t\tvar result = entry.value.forEach(f, baseKey);\n\t\t\t\tif (result != undefined)\n\t\t\t\t{\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tbaseKey.pop();\n\t\t\t});\n\t\t\n\t}\n\treturn undefined;\n}\n\nArrayMap.prototype.clone = function ()\n{\n\t//Diag.trace(\"ArrayMap.clone():\");\n\t//Diag.trace(\"this = \"+this);\n\tvar spawn = new ArrayMap();\n\tthis.forEach(function (entry)\n\t\t{\n\t\t\tspawn.set(entry.key.clone(), entry.value.clone());\n\t\t});\n\t//Diag.trace(\"spawn = \"+spawn);\n\t\n\treturn spawn;\n}\n\nArrayMap.prototype.toString = function ()\n{\n\tvar result = \"{\\n\";\n\tthis.forEach(function (entry)\n\t\t{\n\t\t\tresult += \"\\t\"+entry+\"\\n\";\n\t\t});\n\tresult += \"}\";\n\treturn result;\n}\n\n/*** Private ***/\n\nArrayMap.prototype._looksLike = function (a, b)\n{\n\tif (a == b)\n\t{\n\t\t////Diag.trace(\"Return true: both are primitively equal\");\n\t\treturn true;\n\t}\n\telse if (a instanceof Object && b instanceof Object)\n\t{\n\t\tfor (var i in a)\n\t\t{\n\t\t\tif (!this._looksLike(a[i], b[i]))\n\t\t\t{\n\t\t\t\t////Diag.trace(\"Return false: both are objects, but property \"+i+\"not equal (\"+a[i]+\" != \"+b[i]+\")\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (var i in b)\n\t\t{\n\t\t\t//because all properties of a exist and are equal in b, all it takes is for a property in b to not exist in a, and we know it will not be equal. Checking to see if it equals undefined instead of b[i] saves the access time of b[i].\n\t\t\tif (a[i] == undefined)\n\t\t\t{\n\t\t\t\t////Diag.trace(\"Return false: both are objects, but property \\\"\"+i+\"\\\" not equal (\"+a[i]+\" != \"+b[i]+\")\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t////Diag.trace(\"Return true: both are identical objects\");\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t////Diag.trace(\"Return false: neither both primitive and equal nor both objects\");\n\t\treturn false;\n\t}\n}\n\nArrayMap.prototype._calculateSize = function ()\n{\n\tvar size = 0;\n\t\n\tif (this._isOccupied)\n\t{\n\t\tsize++;\n\t}\n\t\n\tthis._choices.forEach(function (key, value)\n\t\t{\n\t\t\tsize += value.size;\n\t\t});\n\t\n\tthis.size = size;\n}\n\nmodule.exports = ArrayMap;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9BcnJheU1hcC5qcz8yZjNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiogQUJPVVQgKioqKioqXG5cbkFycmF5TWFwXG5cblx0QXV0aG9yOiBUb20gTGFtYiwgTGFtYnl0ZS5jb21cblx0Q3JlYXRlZDogMjAwNy4wOC4xOVxuXHRSZWxlYXNlZDogXG5cdERlc2NyaXB0aW9uOiBBIG1hcCB0aGF0IG9ubHkgdGFrZXMgYXJyYXlzLCBidXQgc3RvcmVzIHRoZW0gbW9yZSBlZmZpY2llbnRseSB0aGFuIGEgbGluZWFyIG1hcC5cblx0XG5cbioqKioqKiAqKioqKiAqKioqKiovXG5cdFxuY29uc3QgRW50cnkgPSByZXF1aXJlKFwiLi9FbnRyeS5qc1wiKTtcbi8vdHJ5IHVzaW5nIG5hdGl2ZSBNYXBcbi8vY29uc3QgTWFwID0gcmVxdWlyZShcIi4vTWFwLmpzXCIpO1xuXG4vKioqKioqKiogQ09OU1RSVUNUT1IgKioqKioqKiovXG5cbmZ1bmN0aW9uIEFycmF5TWFwICgpIFxue1xuXHQvL1VORjogY2xvbmUgZWxlbWVudHM/IElmIGEgcGVyc29uIG1lc3NlcyB3aXRoIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSB0aGV5IHNldCB0byBoYXZlIGEgdmFsdWUsIHRoZW4gZGlzY2FyZCBpdCBhbmQgbWFrZSBhIGZyZXNoIG9uZSwgdGhleSB3aWxsIGV4cGVjdCAuZ2V0IHRvIHJldHVybiB0aGUgc2FtZSB2YWx1ZS4gQnV0IHNpbmNlIHRoZXkgbWVzc2VkIHdpdGggZWxlbWVudHMgb2YgdGhlIGFycmF5IGJlZm9yZSB0aGV5IGdvdCByaWQgb2YgaXQsIHRoZSBlbGVtZW50cyBvZiB0aGUgbm9kZXMgaW4gdGhpcyBtYXAgd2lsbCBoYXZlIGNoYW5nZXMgYW5kIHRoZSB2YWx1ZSB0aGUgdXNlciBpcyBsb29raW5nIGZvciB3aWxsIG5vIGxvbmdlciBoYXZlIHRoZSBzYW1lIGtleS5cblx0dGhpcy5fY2hvaWNlcyA9IG5ldyBNYXAoKTtcblx0dGhpcy5zaXplID0gMDtcbn1cblxuXG4vKioqKioqKiogUFJPUEVSVElFUyAqKioqKioqKi9cblxuLy9VTkY6IHJlY2FsY3VsYXRlIC5zaXplIGF0IHRoZSBlbmQgb2YgLnNldFxuQXJyYXlNYXAucHJvdG90eXBlLnNpemU7XG4vL3RoZSBuZXh0IFxuQXJyYXlNYXAucHJvdG90eXBlLl9jaG9pY2VzO1xuLy90aGUgYW5zd2VyIHRvIC5nZXQoIFtdIClcbkFycmF5TWFwLnByb3RvdHlwZS5fbm9kZVZhbHVlO1xuQXJyYXlNYXAucHJvdG90eXBlLl9pc09jY3VwaWVkO1xuXG5cbi8qKioqKioqKiBNRVRIT0RTICoqKioqKioqL1xuXG5BcnJheU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwga2V5SW5kZXgpXG57XG5cdGtleUluZGV4ID0ga2V5SW5kZXggfHwgMDtcblx0aWYgKGtleUluZGV4ID09IGtleS5sZW5ndGgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fbm9kZVZhbHVlO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHZhciBjdXJyZW50RWxlbWVudCA9IGtleVtrZXlJbmRleF07XG5cdFx0aWYgKHRoaXMuX2Nob2ljZXMuaGFzKGN1cnJlbnRFbGVtZW50KSlcblx0XHR7XG5cdFx0XHR2YXIgbmV4dE5vZGUgPSB0aGlzLl9jaG9pY2VzLmdldChjdXJyZW50RWxlbWVudCk7XG5cdFx0XHR2YXIgbmV4dEdldCA9IG5leHROb2RlLmdldChrZXksIGtleUluZGV4KzEpO1xuXHRcdFx0cmV0dXJuIG5leHRHZXQ7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxufVxuXG5BcnJheU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGtleUluZGV4KVxue1xuXHRrZXlJbmRleCA9IGtleUluZGV4IHx8IDA7XG5cdFxuXHRpZiAoa2V5SW5kZXggPT0ga2V5Lmxlbmd0aClcblx0e1xuXHRcdHRoaXMuX25vZGVWYWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX2lzT2NjdXBpZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2NhbGN1bGF0ZVNpemUoKTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIGN1cnJlbnRFbGVtZW50ID0ga2V5W2tleUluZGV4XTtcblx0XHRpZiAodGhpcy5fY2hvaWNlcy5oYXMoY3VycmVudEVsZW1lbnQpKVxuXHRcdHtcblx0XHRcdHZhciBuZXh0Tm9kZSA9IHRoaXMuX2Nob2ljZXMuZ2V0KGN1cnJlbnRFbGVtZW50KTtcblx0XHRcdFxuXHRcdFx0bmV4dE5vZGUuc2V0KGtleSwgdmFsdWUsIGtleUluZGV4KzEpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9jYWxjdWxhdGVTaXplKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHZhciBuZXh0Tm9kZSA9IG5ldyBBcnJheU1hcCgpO1xuXHRcdFx0bmV4dE5vZGUuc2V0KGtleSwgdmFsdWUsIGtleUluZGV4KzEpO1xuXHRcdFx0XG5cdFx0XHR2YXIgY3VycmVudEVsZW1lbnQgPSBrZXlba2V5SW5kZXhdO1xuXHRcdFx0dGhpcy5fY2hvaWNlcy5zZXQoY3VycmVudEVsZW1lbnQsIG5leHROb2RlKTtcblx0XHRcdHRoaXMuX2NhbGN1bGF0ZVNpemUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fVxuXHRcbn1cblxuQXJyYXlNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXksIGtleUluZGV4KVxue1xuXHRrZXlJbmRleCA9IGtleUluZGV4IHx8IDA7XG5cdFxuXHRpZiAoa2V5SW5kZXggPT0ga2V5Lmxlbmd0aClcblx0e1xuXHRcdHJldHVybiAodGhpcy5faXNPY2N1cGllZCk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIGN1cnJlbnRFbGVtZW50ID0ga2V5W2tleUluZGV4XTtcblx0XHRpZiAodGhpcy5fY2hvaWNlcy5oYXMoY3VycmVudEVsZW1lbnQpKVxuXHRcdHtcblx0XHRcdHZhciBuZXh0Tm9kZSA9IHRoaXMuX2Nob2ljZXMuZ2V0KGN1cnJlbnRFbGVtZW50KTtcblx0XHRcdHJldHVybiBuZXh0Tm9kZS5oYXMoa2V5LCBrZXlJbmRleCsxKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyogSUUgNiBkb2VzIG5vdCBzdXBwb3J0IF9fZGVmaW5lR2V0dGVyX19cbk1hcC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhcInNpemVcIiwgZnVuY3Rpb24gKCkgXG57XG5cdHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDtcbn0pOyovXG5cbkFycmF5TWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYsIGJhc2VLZXkpXG57XG5cdGJhc2VLZXkgPSBiYXNlS2V5IHx8IG5ldyBBcnJheSgpO1xuXHRpZiAodGhpcy5faXNPY2N1cGllZClcblx0e1xuXHRcdHZhciBlbnRyeSA9IG5ldyBFbnRyeShiYXNlS2V5LCB0aGlzLl9ub2RlVmFsdWUpO1xuXHRcdHZhciByZXN1bHQgPSBmKGVudHJ5KTtcblx0XHRpZiAocmVzdWx0ICE9IHVuZGVmaW5lZClcblx0XHR7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXHRcblx0aWYgKHRoaXMuX2Nob2ljZXMuc2l6ZSA+IDApXG5cdHtcblx0XHQvLyEhIWluZWZmaWNpZW50IGNvbnZlcnNpb24gb2YgIHRvIG5hdGl2ZSBzdHlsZVxuXHRcdHRoaXMuX2Nob2ljZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSwgbWFwKVxuXHRcdFx0e1xuXHRcdFx0XHRiYXNlS2V5LnB1c2goZW50cnkua2V5KTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGVudHJ5LnZhbHVlLmZvckVhY2goZiwgYmFzZUtleSk7XG5cdFx0XHRcdGlmIChyZXN1bHQgIT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRiYXNlS2V5LnBvcCgpO1xuXHRcdFx0fSk7XG5cdFx0XG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuQXJyYXlNYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcblx0Ly9EaWFnLnRyYWNlKFwiQXJyYXlNYXAuY2xvbmUoKTpcIik7XG5cdC8vRGlhZy50cmFjZShcInRoaXMgPSBcIit0aGlzKTtcblx0dmFyIHNwYXduID0gbmV3IEFycmF5TWFwKCk7XG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpXG5cdFx0e1xuXHRcdFx0c3Bhd24uc2V0KGVudHJ5LmtleS5jbG9uZSgpLCBlbnRyeS52YWx1ZS5jbG9uZSgpKTtcblx0XHR9KTtcblx0Ly9EaWFnLnRyYWNlKFwic3Bhd24gPSBcIitzcGF3bik7XG5cdFxuXHRyZXR1cm4gc3Bhd247XG59XG5cbkFycmF5TWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciByZXN1bHQgPSBcIntcXG5cIjtcblx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSlcblx0XHR7XG5cdFx0XHRyZXN1bHQgKz0gXCJcXHRcIitlbnRyeStcIlxcblwiO1xuXHRcdH0pO1xuXHRyZXN1bHQgKz0gXCJ9XCI7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiogUHJpdmF0ZSAqKiovXG5cbkFycmF5TWFwLnByb3RvdHlwZS5fbG9va3NMaWtlID0gZnVuY3Rpb24gKGEsIGIpXG57XG5cdGlmIChhID09IGIpXG5cdHtcblx0XHQvLy8vRGlhZy50cmFjZShcIlJldHVybiB0cnVlOiBib3RoIGFyZSBwcmltaXRpdmVseSBlcXVhbFwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRlbHNlIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0ICYmIGIgaW5zdGFuY2VvZiBPYmplY3QpXG5cdHtcblx0XHRmb3IgKHZhciBpIGluIGEpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLl9sb29rc0xpa2UoYVtpXSwgYltpXSkpXG5cdFx0XHR7XG5cdFx0XHRcdC8vLy9EaWFnLnRyYWNlKFwiUmV0dXJuIGZhbHNlOiBib3RoIGFyZSBvYmplY3RzLCBidXQgcHJvcGVydHkgXCIraStcIm5vdCBlcXVhbCAoXCIrYVtpXStcIiAhPSBcIitiW2ldK1wiKVwiKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBpIGluIGIpXG5cdFx0e1xuXHRcdFx0Ly9iZWNhdXNlIGFsbCBwcm9wZXJ0aWVzIG9mIGEgZXhpc3QgYW5kIGFyZSBlcXVhbCBpbiBiLCBhbGwgaXQgdGFrZXMgaXMgZm9yIGEgcHJvcGVydHkgaW4gYiB0byBub3QgZXhpc3QgaW4gYSwgYW5kIHdlIGtub3cgaXQgd2lsbCBub3QgYmUgZXF1YWwuIENoZWNraW5nIHRvIHNlZSBpZiBpdCBlcXVhbHMgdW5kZWZpbmVkIGluc3RlYWQgb2YgYltpXSBzYXZlcyB0aGUgYWNjZXNzIHRpbWUgb2YgYltpXS5cblx0XHRcdGlmIChhW2ldID09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0Ly8vL0RpYWcudHJhY2UoXCJSZXR1cm4gZmFsc2U6IGJvdGggYXJlIG9iamVjdHMsIGJ1dCBwcm9wZXJ0eSBcXFwiXCIraStcIlxcXCIgbm90IGVxdWFsIChcIithW2ldK1wiICE9IFwiK2JbaV0rXCIpXCIpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vLy9EaWFnLnRyYWNlKFwiUmV0dXJuIHRydWU6IGJvdGggYXJlIGlkZW50aWNhbCBvYmplY3RzXCIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdC8vLy9EaWFnLnRyYWNlKFwiUmV0dXJuIGZhbHNlOiBuZWl0aGVyIGJvdGggcHJpbWl0aXZlIGFuZCBlcXVhbCBub3IgYm90aCBvYmplY3RzXCIpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5BcnJheU1hcC5wcm90b3R5cGUuX2NhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgc2l6ZSA9IDA7XG5cdFxuXHRpZiAodGhpcy5faXNPY2N1cGllZClcblx0e1xuXHRcdHNpemUrKztcblx0fVxuXHRcblx0dGhpcy5fY2hvaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKVxuXHRcdHtcblx0XHRcdHNpemUgKz0gdmFsdWUuc2l6ZTtcblx0XHR9KTtcblx0XG5cdHRoaXMuc2l6ZSA9IHNpemU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlNYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0YXRlLWxlYXJuZXIvQXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("const StateLearner = __webpack_require__(7);\nconst TEMPLATE = __webpack_require__(3);\n/* ???: 2017.05.29: Discovered comments said that these were used directly, but I can't see how. Possibly was originally intended as \"types that are intantiated by other classes, but used here\"? The PredictionData type is returned and by one of the methods used by this class (stateLearner.makePrediction).\nconst PredictionData = require(\"PredictionData.js\");\n//const IncidenceMap = require(\"IncidenceMap.js\");\nconst ArrayMap = require(\"ArrayMap.js\");\n*/\n\n//???: is there a new way of doing enumerations in ECMAScript? Should I use it here? \n//faux enumeration\nconst ROCK = \"R\";\nconst PAPER = \"P\";\nconst SCISSORS = \"S\";\nconst allStates = new Array(ROCK, PAPER, SCISSORS);\n\nfunction RPSLearner () {\n  //???: not sure if the root should be an element, or a collection of sibling elements, or what. Choosing single element for now, because that is simpler to implement\n  var dOMRoot = document.createElement(\"div\");\n  dOMRoot.innerHTML = TEMPLATE;\n\n  //???: how do you search within an element for an ID? For now, just search the entire document. This will break if the page has ID collisions.\n  dOMRoot.querySelector(\"#selectRock\").addEventListener(\"click\", selectRock);\n  dOMRoot.querySelector(\"#selectPaper\").addEventListener(\"click\", selectPaper);\n  dOMRoot.querySelector(\"#selectScissors\").addEventListener(\"click\", selectScissors);\n\n  this.rPSAI = new StateLearner();;\n  this.lastPrediction;\n  this.roundsPassed = 0;\n  var aIWins = 0;\n  \n  //???: what do these do?\n  enforceRecall();\n  renewPrediction();\n  \n  this.dOMRoot = dOMRoot;\n}\n\n\n\nfunction enforcePredictionVisibility ()\n{\n  function setInsidesOfTo (node, displayStyle)\n  {\n    if (node.firstChild)\n    {\n      node.firstChild.style.display = displayStyle;\n    }\n  }\n  \n  var checkbox = document.getElementById(\"guessVisible\");\n  if (!checkbox.checked)\n  {\n    setInsidesOfTo(document.getElementById(\"rockGuess\"), \"none\");\n    setInsidesOfTo(document.getElementById(\"paperGuess\"), \"none\");\n    setInsidesOfTo(document.getElementById(\"scissorsGuess\"), \"none\");\n  }\n  else\n  {\n    setInsidesOfTo(document.getElementById(\"rockGuess\"), \"block\");\n    setInsidesOfTo(document.getElementById(\"paperGuess\"), \"block\");\n    setInsidesOfTo(document.getElementById(\"scissorsGuess\"), \"block\");\n  }\n}\n\nfunction enforceRecall ()\n{\n  var recallNode = document.getElementById(\"recall\");\n  \n  var enteredRecall = Number(recallNode.value);\n  if (isNaN(enteredRecall))\n  {\n    //this will also catch misspellings of \"Infinity,\" like \"infinity,\" so we don't need to catch those specifically.\n    enteredRecall = Infinity;\n  }\n  else if (enteredRecall < 0)\n  {\n    enteredRecall = 0;\n  }\n  else\n  {\n    enteredRecall = Math.round(enteredRecall, 1);\n  }\n  \n  rPSAI.recall = enteredRecall;\n  recallNode.value = enteredRecall;\n}\n\nfunction getPredictionCellOf (state)\n{\n  var predictionCell;\n  if (state == ROCK)\n  {\n    predictionCell = document.getElementById(\"rockGuess\");\n  }\n  else if (state == PAPER)\n  {\n    predictionCell = document.getElementById(\"paperGuess\");\n  }\n  else if (state == SCISSORS)\n  {\n    predictionCell = document.getElementById(\"scissorsGuess\");\n  }\n  return predictionCell;\n}\n\nfunction selectRock ()\n{\n  rPSAI.takeInput(ROCK);\n  addHistory(ROCK, lastPrediction);\n  renewPrediction();\n}\n\nfunction selectPaper ()\n{\n  rPSAI.takeInput(PAPER);\n  addHistory(PAPER, lastPrediction);\n  renewPrediction();\n}\n\nfunction selectScissors ()\n{\n  rPSAI.takeInput(SCISSORS);\n  addHistory(SCISSORS, lastPrediction);\n  renewPrediction();\n}\n\nfunction renewPrediction ()\n{\n  //clear old prediction\n  if (lastPrediction != undefined)\n  {\n    var oldPredictionCell = getPredictionCellOf(lastPrediction);\n    var oldPredictionSpan = oldPredictionCell.childNodes[0];\n    oldPredictionCell.removeChild(oldPredictionSpan);\n  }\n  \n  var predictionData = rPSAI.makePrediction();\n  if (predictionData.matchLength == undefined)\n  {\n    //if predictionData.matchLength is undefined, that means that StateLearner was forced to make a prediction without any data.\n    var randomIndex = Math.round(Math.random()*(allStates.length-1));\n    var newPrediction = allStates[randomIndex];\n  }\n  else if (predictionData.states.length >= 2)\n  {\n    //if predictionData.state is an array of more than one element, it means that the contents of the array should be treated as a Set of states that were tied in match length\n    var randomIndex = Math.round(Math.random()*(predictionData.states.length-1));\n    var newPrediction = predictionData.states[randomIndex];\n  }\n  else\n  {\n    var newPrediction = predictionData.states[0];\n  }\n  \n  var predictionCell = getPredictionCellOf(newPrediction);\n  \n  var box = document.createElement(\"span\");\n  box.className = \"aISelect\";\n  predictionCell.appendChild(box);\n  \n  lastPrediction = newPrediction;\n  \n  enforcePredictionVisibility();\n}\n\nfunction addHistory (humanSelection, aISelection)\n{\n  var tableNode = document.getElementById(\"tableBody\");\n  var recentRow = tableNode.getElementsByTagName(\"tr\")[3];\n  //remove the text \"History:\" from recent row and replace it with the round number, because it is going to be shifted down.\n  var roundCell = recentRow.getElementsByTagName(\"td\")[0];\n  var roundText = roundCell.firstChild;\n  //it's roundsPassed-1 because we're labelling the row for the round that has just passed and is being pushed down.\n  roundText.data = roundsPassed+1;\n  \n  var newRow = document.createElement(\"tr\");\n  var historyCell = document.createElement(\"td\");\n  var historyText = document.createTextNode(\"History:\");\n  historyCell.appendChild(historyText);\n  newRow.appendChild(historyCell);\n  \n  var rockCell = document.createElement(\"td\");\n  var paperCell = document.createElement(\"td\");\n  var scissorsCell = document.createElement(\"td\");\n  \n  var cellOf = new Array();\n  cellOf[ROCK] = rockCell;\n  cellOf[PAPER] = paperCell;\n  cellOf[SCISSORS] = scissorsCell;\n  \n  if (humanSelection == aISelection)\n  {\n    var selectionNode = document.createElement(\"span\");\n    selectionNode.className = \"bothSelect\";\n    var selectionCell = cellOf[humanSelection];\n    selectionCell.appendChild(selectionNode);\n  }\n  else\n  {\n    var humanSelectionNode = document.createElement(\"span\");\n    humanSelectionNode.className = \"humanSelect\";\n    var humanSelectionCell = cellOf[humanSelection];\n    humanSelectionCell.appendChild(humanSelectionNode);\n    \n    if (aISelection != undefined)\n    {\n      \n      var aISelectionNode = document.createElement(\"span\");\n      aISelectionNode.className = \"aISelect\";\n      var aISelectionCell = cellOf[aISelection];\n      aISelectionCell.appendChild(aISelectionNode);\n    }\n  }\n  \n  newRow.appendChild(rockCell);\n  newRow.appendChild(paperCell);\n  newRow.appendChild(scissorsCell);\n  \n  tableNode.insertBefore(newRow, recentRow);\n  if (roundsPassed == 0)\n  {\n    //if this is the first round, then the previous round's row that just got pushed down will be the blank placeholder row that the page is initialized with, so delete it for aesthetics' sake.\n    tableNode.removeChild(recentRow);\n  }\n  \n  //update statistics\n  if (aISelection == humanSelection)\n  {\n    aIWins++;\n  }\n  var aIAccuracyNode = document.getElementById(\"aIAccuracy\");\n  var aIGainNode = document.getElementById(\"aIGain\");\n  var normalizedNode = document.getElementById(\"normalizedGain\");\n  //the statistics are blank in the first round, and they can't be filled until two rounds have passed, so we don't have to empty them before adding the new ones if either of these conditions hold.\n  \n  //remove data if roundsPassed >= 1 because only then will there be any data to remove\n  if (roundsPassed >= 1)\n  {\n    var oldAccuracy = aIAccuracyNode.firstChild\n    var oldGain = aIGainNode.firstChild\n    var oldNormalized = normalizedNode.firstChild;\n    aIAccuracyNode.removeChild(oldAccuracy);\n    aIGainNode.removeChild(oldGain);\n    normalizedNode.removeChild(oldNormalized);\n  }\n  \n  var newAccuracy = aIWins/(roundsPassed+1);\n  //*10000/100 dance is done to get an answer to 2 decimal places\n  var newAccuracyPercentage = (Math.round(newAccuracy*10000)/100);\n  var newAccuracyText = document.createTextNode(newAccuracyPercentage+\"%\");\n  aIAccuracyNode.appendChild(newAccuracyText);\n  \n  var newGain = (newAccuracy-(1/allStates.length));\n  var newGainPercentage = Math.round(newGain*10000)/100;\n  var newGainText = document.createTextNode(newGainPercentage+\"%\");\n  aIGainNode.appendChild(newGainText);\n  \n  var newNormalized = newGain/(1/3);\n  var newNormalizedPercentage = Math.round(newNormalized*10000)/100;\n  var newNormalizedText = document.createTextNode(newNormalizedPercentage+\"%\");\n  normalizedNode.appendChild(newNormalizedText);\n  \n  roundsPassed++;\n}\n\nmodule.exports = RPSLearner;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9SUFNMZWFybmVyLmpzPzMxNTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU3RhdGVMZWFybmVyID0gcmVxdWlyZShcInN0YXRlLWxlYXJuZXJcIik7XG5jb25zdCBURU1QTEFURSA9IHJlcXVpcmUoXCIuL2luZGV4Lmh0bWxcIik7XG4vKiA/Pz86IDIwMTcuMDUuMjk6IERpc2NvdmVyZWQgY29tbWVudHMgc2FpZCB0aGF0IHRoZXNlIHdlcmUgdXNlZCBkaXJlY3RseSwgYnV0IEkgY2FuJ3Qgc2VlIGhvdy4gUG9zc2libHkgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgYXMgXCJ0eXBlcyB0aGF0IGFyZSBpbnRhbnRpYXRlZCBieSBvdGhlciBjbGFzc2VzLCBidXQgdXNlZCBoZXJlXCI/IFRoZSBQcmVkaWN0aW9uRGF0YSB0eXBlIGlzIHJldHVybmVkIGFuZCBieSBvbmUgb2YgdGhlIG1ldGhvZHMgdXNlZCBieSB0aGlzIGNsYXNzIChzdGF0ZUxlYXJuZXIubWFrZVByZWRpY3Rpb24pLlxuY29uc3QgUHJlZGljdGlvbkRhdGEgPSByZXF1aXJlKFwiUHJlZGljdGlvbkRhdGEuanNcIik7XG4vL2NvbnN0IEluY2lkZW5jZU1hcCA9IHJlcXVpcmUoXCJJbmNpZGVuY2VNYXAuanNcIik7XG5jb25zdCBBcnJheU1hcCA9IHJlcXVpcmUoXCJBcnJheU1hcC5qc1wiKTtcbiovXG5cbi8vPz8/OiBpcyB0aGVyZSBhIG5ldyB3YXkgb2YgZG9pbmcgZW51bWVyYXRpb25zIGluIEVDTUFTY3JpcHQ/IFNob3VsZCBJIHVzZSBpdCBoZXJlPyBcbi8vZmF1eCBlbnVtZXJhdGlvblxuY29uc3QgUk9DSyA9IFwiUlwiO1xuY29uc3QgUEFQRVIgPSBcIlBcIjtcbmNvbnN0IFNDSVNTT1JTID0gXCJTXCI7XG5jb25zdCBhbGxTdGF0ZXMgPSBuZXcgQXJyYXkoUk9DSywgUEFQRVIsIFNDSVNTT1JTKTtcblxuZnVuY3Rpb24gUlBTTGVhcm5lciAoKSB7XG4gIC8vPz8/OiBub3Qgc3VyZSBpZiB0aGUgcm9vdCBzaG91bGQgYmUgYW4gZWxlbWVudCwgb3IgYSBjb2xsZWN0aW9uIG9mIHNpYmxpbmcgZWxlbWVudHMsIG9yIHdoYXQuIENob29zaW5nIHNpbmdsZSBlbGVtZW50IGZvciBub3csIGJlY2F1c2UgdGhhdCBpcyBzaW1wbGVyIHRvIGltcGxlbWVudFxuICB2YXIgZE9NUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRPTVJvb3QuaW5uZXJIVE1MID0gVEVNUExBVEU7XG5cbiAgLy8/Pz86IGhvdyBkbyB5b3Ugc2VhcmNoIHdpdGhpbiBhbiBlbGVtZW50IGZvciBhbiBJRD8gRm9yIG5vdywganVzdCBzZWFyY2ggdGhlIGVudGlyZSBkb2N1bWVudC4gVGhpcyB3aWxsIGJyZWFrIGlmIHRoZSBwYWdlIGhhcyBJRCBjb2xsaXNpb25zLlxuICBkT01Sb290LnF1ZXJ5U2VsZWN0b3IoXCIjc2VsZWN0Um9ja1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc2VsZWN0Um9jayk7XG4gIGRPTVJvb3QucXVlcnlTZWxlY3RvcihcIiNzZWxlY3RQYXBlclwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc2VsZWN0UGFwZXIpO1xuICBkT01Sb290LnF1ZXJ5U2VsZWN0b3IoXCIjc2VsZWN0U2Npc3NvcnNcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHNlbGVjdFNjaXNzb3JzKTtcblxuICB0aGlzLnJQU0FJID0gbmV3IFN0YXRlTGVhcm5lcigpOztcbiAgdGhpcy5sYXN0UHJlZGljdGlvbjtcbiAgdGhpcy5yb3VuZHNQYXNzZWQgPSAwO1xuICB2YXIgYUlXaW5zID0gMDtcbiAgXG4gIC8vPz8/OiB3aGF0IGRvIHRoZXNlIGRvP1xuICBlbmZvcmNlUmVjYWxsKCk7XG4gIHJlbmV3UHJlZGljdGlvbigpO1xuICBcbiAgdGhpcy5kT01Sb290ID0gZE9NUm9vdDtcbn1cblxuXG5cbmZ1bmN0aW9uIGVuZm9yY2VQcmVkaWN0aW9uVmlzaWJpbGl0eSAoKVxue1xuICBmdW5jdGlvbiBzZXRJbnNpZGVzT2ZUbyAobm9kZSwgZGlzcGxheVN0eWxlKVxuICB7XG4gICAgaWYgKG5vZGUuZmlyc3RDaGlsZClcbiAgICB7XG4gICAgICBub2RlLmZpcnN0Q2hpbGQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXlTdHlsZTtcbiAgICB9XG4gIH1cbiAgXG4gIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ3Vlc3NWaXNpYmxlXCIpO1xuICBpZiAoIWNoZWNrYm94LmNoZWNrZWQpXG4gIHtcbiAgICBzZXRJbnNpZGVzT2ZUbyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvY2tHdWVzc1wiKSwgXCJub25lXCIpO1xuICAgIHNldEluc2lkZXNPZlRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFwZXJHdWVzc1wiKSwgXCJub25lXCIpO1xuICAgIHNldEluc2lkZXNPZlRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2Npc3NvcnNHdWVzc1wiKSwgXCJub25lXCIpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHNldEluc2lkZXNPZlRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9ja0d1ZXNzXCIpLCBcImJsb2NrXCIpO1xuICAgIHNldEluc2lkZXNPZlRvKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFwZXJHdWVzc1wiKSwgXCJibG9ja1wiKTtcbiAgICBzZXRJbnNpZGVzT2ZUbyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjaXNzb3JzR3Vlc3NcIiksIFwiYmxvY2tcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5mb3JjZVJlY2FsbCAoKVxue1xuICB2YXIgcmVjYWxsTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjYWxsXCIpO1xuICBcbiAgdmFyIGVudGVyZWRSZWNhbGwgPSBOdW1iZXIocmVjYWxsTm9kZS52YWx1ZSk7XG4gIGlmIChpc05hTihlbnRlcmVkUmVjYWxsKSlcbiAge1xuICAgIC8vdGhpcyB3aWxsIGFsc28gY2F0Y2ggbWlzc3BlbGxpbmdzIG9mIFwiSW5maW5pdHksXCIgbGlrZSBcImluZmluaXR5LFwiIHNvIHdlIGRvbid0IG5lZWQgdG8gY2F0Y2ggdGhvc2Ugc3BlY2lmaWNhbGx5LlxuICAgIGVudGVyZWRSZWNhbGwgPSBJbmZpbml0eTtcbiAgfVxuICBlbHNlIGlmIChlbnRlcmVkUmVjYWxsIDwgMClcbiAge1xuICAgIGVudGVyZWRSZWNhbGwgPSAwO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIGVudGVyZWRSZWNhbGwgPSBNYXRoLnJvdW5kKGVudGVyZWRSZWNhbGwsIDEpO1xuICB9XG4gIFxuICByUFNBSS5yZWNhbGwgPSBlbnRlcmVkUmVjYWxsO1xuICByZWNhbGxOb2RlLnZhbHVlID0gZW50ZXJlZFJlY2FsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlZGljdGlvbkNlbGxPZiAoc3RhdGUpXG57XG4gIHZhciBwcmVkaWN0aW9uQ2VsbDtcbiAgaWYgKHN0YXRlID09IFJPQ0spXG4gIHtcbiAgICBwcmVkaWN0aW9uQ2VsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9ja0d1ZXNzXCIpO1xuICB9XG4gIGVsc2UgaWYgKHN0YXRlID09IFBBUEVSKVxuICB7XG4gICAgcHJlZGljdGlvbkNlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhcGVyR3Vlc3NcIik7XG4gIH1cbiAgZWxzZSBpZiAoc3RhdGUgPT0gU0NJU1NPUlMpXG4gIHtcbiAgICBwcmVkaWN0aW9uQ2VsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2Npc3NvcnNHdWVzc1wiKTtcbiAgfVxuICByZXR1cm4gcHJlZGljdGlvbkNlbGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFJvY2sgKClcbntcbiAgclBTQUkudGFrZUlucHV0KFJPQ0spO1xuICBhZGRIaXN0b3J5KFJPQ0ssIGxhc3RQcmVkaWN0aW9uKTtcbiAgcmVuZXdQcmVkaWN0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFBhcGVyICgpXG57XG4gIHJQU0FJLnRha2VJbnB1dChQQVBFUik7XG4gIGFkZEhpc3RvcnkoUEFQRVIsIGxhc3RQcmVkaWN0aW9uKTtcbiAgcmVuZXdQcmVkaWN0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFNjaXNzb3JzICgpXG57XG4gIHJQU0FJLnRha2VJbnB1dChTQ0lTU09SUyk7XG4gIGFkZEhpc3RvcnkoU0NJU1NPUlMsIGxhc3RQcmVkaWN0aW9uKTtcbiAgcmVuZXdQcmVkaWN0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHJlbmV3UHJlZGljdGlvbiAoKVxue1xuICAvL2NsZWFyIG9sZCBwcmVkaWN0aW9uXG4gIGlmIChsYXN0UHJlZGljdGlvbiAhPSB1bmRlZmluZWQpXG4gIHtcbiAgICB2YXIgb2xkUHJlZGljdGlvbkNlbGwgPSBnZXRQcmVkaWN0aW9uQ2VsbE9mKGxhc3RQcmVkaWN0aW9uKTtcbiAgICB2YXIgb2xkUHJlZGljdGlvblNwYW4gPSBvbGRQcmVkaWN0aW9uQ2VsbC5jaGlsZE5vZGVzWzBdO1xuICAgIG9sZFByZWRpY3Rpb25DZWxsLnJlbW92ZUNoaWxkKG9sZFByZWRpY3Rpb25TcGFuKTtcbiAgfVxuICBcbiAgdmFyIHByZWRpY3Rpb25EYXRhID0gclBTQUkubWFrZVByZWRpY3Rpb24oKTtcbiAgaWYgKHByZWRpY3Rpb25EYXRhLm1hdGNoTGVuZ3RoID09IHVuZGVmaW5lZClcbiAge1xuICAgIC8vaWYgcHJlZGljdGlvbkRhdGEubWF0Y2hMZW5ndGggaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHRoYXQgU3RhdGVMZWFybmVyIHdhcyBmb3JjZWQgdG8gbWFrZSBhIHByZWRpY3Rpb24gd2l0aG91dCBhbnkgZGF0YS5cbiAgICB2YXIgcmFuZG9tSW5kZXggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqKGFsbFN0YXRlcy5sZW5ndGgtMSkpO1xuICAgIHZhciBuZXdQcmVkaWN0aW9uID0gYWxsU3RhdGVzW3JhbmRvbUluZGV4XTtcbiAgfVxuICBlbHNlIGlmIChwcmVkaWN0aW9uRGF0YS5zdGF0ZXMubGVuZ3RoID49IDIpXG4gIHtcbiAgICAvL2lmIHByZWRpY3Rpb25EYXRhLnN0YXRlIGlzIGFuIGFycmF5IG9mIG1vcmUgdGhhbiBvbmUgZWxlbWVudCwgaXQgbWVhbnMgdGhhdCB0aGUgY29udGVudHMgb2YgdGhlIGFycmF5IHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgU2V0IG9mIHN0YXRlcyB0aGF0IHdlcmUgdGllZCBpbiBtYXRjaCBsZW5ndGhcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqKHByZWRpY3Rpb25EYXRhLnN0YXRlcy5sZW5ndGgtMSkpO1xuICAgIHZhciBuZXdQcmVkaWN0aW9uID0gcHJlZGljdGlvbkRhdGEuc3RhdGVzW3JhbmRvbUluZGV4XTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICB2YXIgbmV3UHJlZGljdGlvbiA9IHByZWRpY3Rpb25EYXRhLnN0YXRlc1swXTtcbiAgfVxuICBcbiAgdmFyIHByZWRpY3Rpb25DZWxsID0gZ2V0UHJlZGljdGlvbkNlbGxPZihuZXdQcmVkaWN0aW9uKTtcbiAgXG4gIHZhciBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgYm94LmNsYXNzTmFtZSA9IFwiYUlTZWxlY3RcIjtcbiAgcHJlZGljdGlvbkNlbGwuYXBwZW5kQ2hpbGQoYm94KTtcbiAgXG4gIGxhc3RQcmVkaWN0aW9uID0gbmV3UHJlZGljdGlvbjtcbiAgXG4gIGVuZm9yY2VQcmVkaWN0aW9uVmlzaWJpbGl0eSgpO1xufVxuXG5mdW5jdGlvbiBhZGRIaXN0b3J5IChodW1hblNlbGVjdGlvbiwgYUlTZWxlY3Rpb24pXG57XG4gIHZhciB0YWJsZU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhYmxlQm9keVwiKTtcbiAgdmFyIHJlY2VudFJvdyA9IHRhYmxlTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRyXCIpWzNdO1xuICAvL3JlbW92ZSB0aGUgdGV4dCBcIkhpc3Rvcnk6XCIgZnJvbSByZWNlbnQgcm93IGFuZCByZXBsYWNlIGl0IHdpdGggdGhlIHJvdW5kIG51bWJlciwgYmVjYXVzZSBpdCBpcyBnb2luZyB0byBiZSBzaGlmdGVkIGRvd24uXG4gIHZhciByb3VuZENlbGwgPSByZWNlbnRSb3cuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKVswXTtcbiAgdmFyIHJvdW5kVGV4dCA9IHJvdW5kQ2VsbC5maXJzdENoaWxkO1xuICAvL2l0J3Mgcm91bmRzUGFzc2VkLTEgYmVjYXVzZSB3ZSdyZSBsYWJlbGxpbmcgdGhlIHJvdyBmb3IgdGhlIHJvdW5kIHRoYXQgaGFzIGp1c3QgcGFzc2VkIGFuZCBpcyBiZWluZyBwdXNoZWQgZG93bi5cbiAgcm91bmRUZXh0LmRhdGEgPSByb3VuZHNQYXNzZWQrMTtcbiAgXG4gIHZhciBuZXdSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XG4gIHZhciBoaXN0b3J5Q2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgdmFyIGhpc3RvcnlUZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJIaXN0b3J5OlwiKTtcbiAgaGlzdG9yeUNlbGwuYXBwZW5kQ2hpbGQoaGlzdG9yeVRleHQpO1xuICBuZXdSb3cuYXBwZW5kQ2hpbGQoaGlzdG9yeUNlbGwpO1xuICBcbiAgdmFyIHJvY2tDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICB2YXIgcGFwZXJDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICB2YXIgc2Npc3NvcnNDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICBcbiAgdmFyIGNlbGxPZiA9IG5ldyBBcnJheSgpO1xuICBjZWxsT2ZbUk9DS10gPSByb2NrQ2VsbDtcbiAgY2VsbE9mW1BBUEVSXSA9IHBhcGVyQ2VsbDtcbiAgY2VsbE9mW1NDSVNTT1JTXSA9IHNjaXNzb3JzQ2VsbDtcbiAgXG4gIGlmIChodW1hblNlbGVjdGlvbiA9PSBhSVNlbGVjdGlvbilcbiAge1xuICAgIHZhciBzZWxlY3Rpb25Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc2VsZWN0aW9uTm9kZS5jbGFzc05hbWUgPSBcImJvdGhTZWxlY3RcIjtcbiAgICB2YXIgc2VsZWN0aW9uQ2VsbCA9IGNlbGxPZltodW1hblNlbGVjdGlvbl07XG4gICAgc2VsZWN0aW9uQ2VsbC5hcHBlbmRDaGlsZChzZWxlY3Rpb25Ob2RlKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICB2YXIgaHVtYW5TZWxlY3Rpb25Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaHVtYW5TZWxlY3Rpb25Ob2RlLmNsYXNzTmFtZSA9IFwiaHVtYW5TZWxlY3RcIjtcbiAgICB2YXIgaHVtYW5TZWxlY3Rpb25DZWxsID0gY2VsbE9mW2h1bWFuU2VsZWN0aW9uXTtcbiAgICBodW1hblNlbGVjdGlvbkNlbGwuYXBwZW5kQ2hpbGQoaHVtYW5TZWxlY3Rpb25Ob2RlKTtcbiAgICBcbiAgICBpZiAoYUlTZWxlY3Rpb24gIT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgIFxuICAgICAgdmFyIGFJU2VsZWN0aW9uTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgYUlTZWxlY3Rpb25Ob2RlLmNsYXNzTmFtZSA9IFwiYUlTZWxlY3RcIjtcbiAgICAgIHZhciBhSVNlbGVjdGlvbkNlbGwgPSBjZWxsT2ZbYUlTZWxlY3Rpb25dO1xuICAgICAgYUlTZWxlY3Rpb25DZWxsLmFwcGVuZENoaWxkKGFJU2VsZWN0aW9uTm9kZSk7XG4gICAgfVxuICB9XG4gIFxuICBuZXdSb3cuYXBwZW5kQ2hpbGQocm9ja0NlbGwpO1xuICBuZXdSb3cuYXBwZW5kQ2hpbGQocGFwZXJDZWxsKTtcbiAgbmV3Um93LmFwcGVuZENoaWxkKHNjaXNzb3JzQ2VsbCk7XG4gIFxuICB0YWJsZU5vZGUuaW5zZXJ0QmVmb3JlKG5ld1JvdywgcmVjZW50Um93KTtcbiAgaWYgKHJvdW5kc1Bhc3NlZCA9PSAwKVxuICB7XG4gICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCByb3VuZCwgdGhlbiB0aGUgcHJldmlvdXMgcm91bmQncyByb3cgdGhhdCBqdXN0IGdvdCBwdXNoZWQgZG93biB3aWxsIGJlIHRoZSBibGFuayBwbGFjZWhvbGRlciByb3cgdGhhdCB0aGUgcGFnZSBpcyBpbml0aWFsaXplZCB3aXRoLCBzbyBkZWxldGUgaXQgZm9yIGFlc3RoZXRpY3MnIHNha2UuXG4gICAgdGFibGVOb2RlLnJlbW92ZUNoaWxkKHJlY2VudFJvdyk7XG4gIH1cbiAgXG4gIC8vdXBkYXRlIHN0YXRpc3RpY3NcbiAgaWYgKGFJU2VsZWN0aW9uID09IGh1bWFuU2VsZWN0aW9uKVxuICB7XG4gICAgYUlXaW5zKys7XG4gIH1cbiAgdmFyIGFJQWNjdXJhY3lOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhSUFjY3VyYWN5XCIpO1xuICB2YXIgYUlHYWluTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYUlHYWluXCIpO1xuICB2YXIgbm9ybWFsaXplZE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vcm1hbGl6ZWRHYWluXCIpO1xuICAvL3RoZSBzdGF0aXN0aWNzIGFyZSBibGFuayBpbiB0aGUgZmlyc3Qgcm91bmQsIGFuZCB0aGV5IGNhbid0IGJlIGZpbGxlZCB1bnRpbCB0d28gcm91bmRzIGhhdmUgcGFzc2VkLCBzbyB3ZSBkb24ndCBoYXZlIHRvIGVtcHR5IHRoZW0gYmVmb3JlIGFkZGluZyB0aGUgbmV3IG9uZXMgaWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgaG9sZC5cbiAgXG4gIC8vcmVtb3ZlIGRhdGEgaWYgcm91bmRzUGFzc2VkID49IDEgYmVjYXVzZSBvbmx5IHRoZW4gd2lsbCB0aGVyZSBiZSBhbnkgZGF0YSB0byByZW1vdmVcbiAgaWYgKHJvdW5kc1Bhc3NlZCA+PSAxKVxuICB7XG4gICAgdmFyIG9sZEFjY3VyYWN5ID0gYUlBY2N1cmFjeU5vZGUuZmlyc3RDaGlsZFxuICAgIHZhciBvbGRHYWluID0gYUlHYWluTm9kZS5maXJzdENoaWxkXG4gICAgdmFyIG9sZE5vcm1hbGl6ZWQgPSBub3JtYWxpemVkTm9kZS5maXJzdENoaWxkO1xuICAgIGFJQWNjdXJhY3lOb2RlLnJlbW92ZUNoaWxkKG9sZEFjY3VyYWN5KTtcbiAgICBhSUdhaW5Ob2RlLnJlbW92ZUNoaWxkKG9sZEdhaW4pO1xuICAgIG5vcm1hbGl6ZWROb2RlLnJlbW92ZUNoaWxkKG9sZE5vcm1hbGl6ZWQpO1xuICB9XG4gIFxuICB2YXIgbmV3QWNjdXJhY3kgPSBhSVdpbnMvKHJvdW5kc1Bhc3NlZCsxKTtcbiAgLy8qMTAwMDAvMTAwIGRhbmNlIGlzIGRvbmUgdG8gZ2V0IGFuIGFuc3dlciB0byAyIGRlY2ltYWwgcGxhY2VzXG4gIHZhciBuZXdBY2N1cmFjeVBlcmNlbnRhZ2UgPSAoTWF0aC5yb3VuZChuZXdBY2N1cmFjeSoxMDAwMCkvMTAwKTtcbiAgdmFyIG5ld0FjY3VyYWN5VGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld0FjY3VyYWN5UGVyY2VudGFnZStcIiVcIik7XG4gIGFJQWNjdXJhY3lOb2RlLmFwcGVuZENoaWxkKG5ld0FjY3VyYWN5VGV4dCk7XG4gIFxuICB2YXIgbmV3R2FpbiA9IChuZXdBY2N1cmFjeS0oMS9hbGxTdGF0ZXMubGVuZ3RoKSk7XG4gIHZhciBuZXdHYWluUGVyY2VudGFnZSA9IE1hdGgucm91bmQobmV3R2FpbioxMDAwMCkvMTAwO1xuICB2YXIgbmV3R2FpblRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdHYWluUGVyY2VudGFnZStcIiVcIik7XG4gIGFJR2Fpbk5vZGUuYXBwZW5kQ2hpbGQobmV3R2FpblRleHQpO1xuICBcbiAgdmFyIG5ld05vcm1hbGl6ZWQgPSBuZXdHYWluLygxLzMpO1xuICB2YXIgbmV3Tm9ybWFsaXplZFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKG5ld05vcm1hbGl6ZWQqMTAwMDApLzEwMDtcbiAgdmFyIG5ld05vcm1hbGl6ZWRUZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3Tm9ybWFsaXplZFBlcmNlbnRhZ2UrXCIlXCIpO1xuICBub3JtYWxpemVkTm9kZS5hcHBlbmRDaGlsZChuZXdOb3JtYWxpemVkVGV4dCk7XG4gIFxuICByb3VuZHNQYXNzZWQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSUFNMZWFybmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L1JQU0xlYXJuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("const RPSLearner = __webpack_require__(1);\n\nwindow.onload = function () {\n  var rPSLearner = new RPSLearner();\n  document.body.appendChild(rPSLearner.dOMRoot);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9hcHAuanM/MjdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSUFNMZWFybmVyID0gcmVxdWlyZShcIi4vUlBTTGVhcm5lci5qc1wiKTtcblxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJQU0xlYXJuZXIgPSBuZXcgUlBTTGVhcm5lcigpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJQU0xlYXJuZXIuZE9NUm9vdCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvYXBwLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("module.exports = \"<!--<doctype html>\\r\\n<html>\\r\\n\\t<head>\\r\\n\\t\\t<title>RPS Learner v.1.3</title>\\r\\n\\t\\t<link rel=\\\"stylesheet\\\" type=\\\"text/less\\\" src=\\\"index.less\\\">-->\\r\\n\\t\\t<!--<script type=\\\"text/javascript\\\" src=\\\"index.js\\\">\\r\\n\\t</head>\\r\\n\\t<body>-->\\r\\n\\t\\t<b>Rock, Paper, Scissors Learner:</b><br />\\r\\n\\t\\tan AI opponent that plays and gets better through practice. <a href=\\\"AboutRPSLearner.html\\\">More information...</a><br />\\r\\n\\t\\t<div id=\\\"centeredBlock\\\">\\r\\n\\t\\t\\t<p><b>Note:</b> The computer's predictions are just that: <i>predictions</i> of your next choice. If the computer were actually choosing its own moves, as you are, it would just choose the move that would beat its prediction. In this demonstration, the computer's predictions are just left at predictions so that it's easier to see when it wins (whenever your choice and its prediction overlap, which is purple in the history.)</p>\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t<table id=\\\"rPSTable\\\">\\r\\n\\t\\t\\t\\t\\t<thead>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td class=\\\"indexColumn\\\"></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td class=\\\"stateColumn\\\">Rock</td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td class=\\\"stateColumn\\\">Paper</td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td class=\\\"stateColumn\\\">Scissors</td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t</thead>\\r\\n\\t\\t\\t\\t\\t<tbody id=\\\"tableBody\\\">\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td><span class=\\\"humanSelect\\\" style=\\\"float:left; width:1em; height:1em;\\\"></span>Your choice</td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td id=\\\"selectRock\\\" class=\\\"button\\\" >&#x235C;<!-- alternative button labels: Rock &#x25EF; &#x235C; &#x2296; &#x2295; &#x2297; &#x20DD; --></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td id=\\\"selectPaper\\\" class=\\\"button\\\">&#x2395;<!-- alternative button labels: Paper --></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td id=\\\"selectScissors\\\" class=\\\"button\\\">&#x2704;<!-- alternative button labels: Scissors &#x2703; --></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td><span class=\\\"aISelect\\\" style=\\\"float:left; width:1em; height:1em;\\\"></span>AI's prediction</td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td><div id=\\\"rockGuess\\\"></div></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td><div id=\\\"paperGuess\\\"></div></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td><div id=\\\"scissorsGuess\\\"></div></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td>History:</td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td></td>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t</tbody>\\r\\n\\t\\t\\t\\t</table>\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t<!-- options section -->\\r\\n\\t\\t\\t\\t<input id=\\\"guessVisible\\\" name=\\\"guessVisible\\\" type=\\\"checkbox\\\" onclick=\\\"enforcePredictionVisibility()\\\" />AI Prediction visible<br />\\r\\n\\t\\t\\t\\tRecall limit: <input id=\\\"recall\\\" name=\\\"recall\\\" type=\\\"text\\\" onblur=\\\"enforceRecall()\\\" value=\\\"Infinity\\\" style=\\\"font-size:18px;width:5em;font-family:monospace;\\\"><br />\\r\\n\\t\\t\\t\\t<br />\\r\\n\\t\\t\\t\\t<hr />\\r\\n\\t\\t\\t\\t<br />\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t<table id=\\\"statistics\\\">\\r\\n\\t\\t\\t\\t\\t<tbody>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td>AI Accuracy:</td>\\t<td><span id=\\\"aIAccuracy\\\"></span></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td>Gain from AI:</td>\\t<td><span id=\\\"aIGain\\\"></span></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t\\t\\t\\t<td>Normalized:</td>\\t<td><span id=\\\"normalizedGain\\\"></span></td>\\r\\n\\t\\t\\t\\t\\t\\t</tr>\\r\\n\\t\\t\\t\\t\\t</tbody>\\r\\n\\t\\t\\t\\t</table>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<br />\\r\\n\\t\\t\\t<br />\\r\\n\\t\\t\\t<br />\\r\\n\\t\\t\\t<br />\\r\\n\\t\\t</div>\\r\\n\\t<!--</body>\\r\\n</html>-->\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9pbmRleC5odG1sP2FmMjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjwhLS08ZG9jdHlwZSBodG1sPlxcclxcbjxodG1sPlxcclxcblxcdDxoZWFkPlxcclxcblxcdFxcdDx0aXRsZT5SUFMgTGVhcm5lciB2LjEuMzwvdGl0bGU+XFxyXFxuXFx0XFx0PGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiB0eXBlPVxcXCJ0ZXh0L2xlc3NcXFwiIHNyYz1cXFwiaW5kZXgubGVzc1xcXCI+LS0+XFxyXFxuXFx0XFx0PCEtLTxzY3JpcHQgdHlwZT1cXFwidGV4dC9qYXZhc2NyaXB0XFxcIiBzcmM9XFxcImluZGV4LmpzXFxcIj5cXHJcXG5cXHQ8L2hlYWQ+XFxyXFxuXFx0PGJvZHk+LS0+XFxyXFxuXFx0XFx0PGI+Um9jaywgUGFwZXIsIFNjaXNzb3JzIExlYXJuZXI6PC9iPjxiciAvPlxcclxcblxcdFxcdGFuIEFJIG9wcG9uZW50IHRoYXQgcGxheXMgYW5kIGdldHMgYmV0dGVyIHRocm91Z2ggcHJhY3RpY2UuIDxhIGhyZWY9XFxcIkFib3V0UlBTTGVhcm5lci5odG1sXFxcIj5Nb3JlIGluZm9ybWF0aW9uLi4uPC9hPjxiciAvPlxcclxcblxcdFxcdDxkaXYgaWQ9XFxcImNlbnRlcmVkQmxvY2tcXFwiPlxcclxcblxcdFxcdFxcdDxwPjxiPk5vdGU6PC9iPiBUaGUgY29tcHV0ZXIncyBwcmVkaWN0aW9ucyBhcmUganVzdCB0aGF0OiA8aT5wcmVkaWN0aW9uczwvaT4gb2YgeW91ciBuZXh0IGNob2ljZS4gSWYgdGhlIGNvbXB1dGVyIHdlcmUgYWN0dWFsbHkgY2hvb3NpbmcgaXRzIG93biBtb3ZlcywgYXMgeW91IGFyZSwgaXQgd291bGQganVzdCBjaG9vc2UgdGhlIG1vdmUgdGhhdCB3b3VsZCBiZWF0IGl0cyBwcmVkaWN0aW9uLiBJbiB0aGlzIGRlbW9uc3RyYXRpb24sIHRoZSBjb21wdXRlcidzIHByZWRpY3Rpb25zIGFyZSBqdXN0IGxlZnQgYXQgcHJlZGljdGlvbnMgc28gdGhhdCBpdCdzIGVhc2llciB0byBzZWUgd2hlbiBpdCB3aW5zICh3aGVuZXZlciB5b3VyIGNob2ljZSBhbmQgaXRzIHByZWRpY3Rpb24gb3ZlcmxhcCwgd2hpY2ggaXMgcHVycGxlIGluIHRoZSBoaXN0b3J5Lik8L3A+XFxyXFxuXFx0XFx0XFx0XFxyXFxuXFx0XFx0XFx0PGRpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8dGFibGUgaWQ9XFxcInJQU1RhYmxlXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8dGhlYWQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBjbGFzcz1cXFwiaW5kZXhDb2x1bW5cXFwiPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkIGNsYXNzPVxcXCJzdGF0ZUNvbHVtblxcXCI+Um9jazwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkIGNsYXNzPVxcXCJzdGF0ZUNvbHVtblxcXCI+UGFwZXI8L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBjbGFzcz1cXFwic3RhdGVDb2x1bW5cXFwiPlNjaXNzb3JzPC90ZD5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RyPlxcclxcblxcdFxcdFxcdFxcdFxcdDwvdGhlYWQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHRib2R5IGlkPVxcXCJ0YWJsZUJvZHlcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDx0cj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8dGQ+PHNwYW4gY2xhc3M9XFxcImh1bWFuU2VsZWN0XFxcIiBzdHlsZT1cXFwiZmxvYXQ6bGVmdDsgd2lkdGg6MWVtOyBoZWlnaHQ6MWVtO1xcXCI+PC9zcGFuPllvdXIgY2hvaWNlPC90ZD5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8dGQgaWQ9XFxcInNlbGVjdFJvY2tcXFwiIGNsYXNzPVxcXCJidXR0b25cXFwiID4mI3gyMzVDOzwhLS0gYWx0ZXJuYXRpdmUgYnV0dG9uIGxhYmVsczogUm9jayAmI3gyNUVGOyAmI3gyMzVDOyAmI3gyMjk2OyAmI3gyMjk1OyAmI3gyMjk3OyAmI3gyMEREOyAtLT48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBpZD1cXFwic2VsZWN0UGFwZXJcXFwiIGNsYXNzPVxcXCJidXR0b25cXFwiPiYjeDIzOTU7PCEtLSBhbHRlcm5hdGl2ZSBidXR0b24gbGFiZWxzOiBQYXBlciAtLT48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBpZD1cXFwic2VsZWN0U2Npc3NvcnNcXFwiIGNsYXNzPVxcXCJidXR0b25cXFwiPiYjeDI3MDQ7PCEtLSBhbHRlcm5hdGl2ZSBidXR0b24gbGFiZWxzOiBTY2lzc29ycyAmI3gyNzAzOyAtLT48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD48c3BhbiBjbGFzcz1cXFwiYUlTZWxlY3RcXFwiIHN0eWxlPVxcXCJmbG9hdDpsZWZ0OyB3aWR0aDoxZW07IGhlaWdodDoxZW07XFxcIj48L3NwYW4+QUkncyBwcmVkaWN0aW9uPC90ZD5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8dGQ+PGRpdiBpZD1cXFwicm9ja0d1ZXNzXFxcIj48L2Rpdj48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD48ZGl2IGlkPVxcXCJwYXBlckd1ZXNzXFxcIj48L2Rpdj48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD48ZGl2IGlkPVxcXCJzY2lzc29yc0d1ZXNzXFxcIj48L2Rpdj48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD5IaXN0b3J5OjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC90cj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L3Rib2R5PlxcclxcblxcdFxcdFxcdFxcdDwvdGFibGU+XFxyXFxuXFx0XFx0XFx0XFx0XFxyXFxuXFx0XFx0XFx0XFx0PCEtLSBvcHRpb25zIHNlY3Rpb24gLS0+XFxyXFxuXFx0XFx0XFx0XFx0PGlucHV0IGlkPVxcXCJndWVzc1Zpc2libGVcXFwiIG5hbWU9XFxcImd1ZXNzVmlzaWJsZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG9uY2xpY2s9XFxcImVuZm9yY2VQcmVkaWN0aW9uVmlzaWJpbGl0eSgpXFxcIiAvPkFJIFByZWRpY3Rpb24gdmlzaWJsZTxiciAvPlxcclxcblxcdFxcdFxcdFxcdFJlY2FsbCBsaW1pdDogPGlucHV0IGlkPVxcXCJyZWNhbGxcXFwiIG5hbWU9XFxcInJlY2FsbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgb25ibHVyPVxcXCJlbmZvcmNlUmVjYWxsKClcXFwiIHZhbHVlPVxcXCJJbmZpbml0eVxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxOHB4O3dpZHRoOjVlbTtmb250LWZhbWlseTptb25vc3BhY2U7XFxcIj48YnIgLz5cXHJcXG5cXHRcXHRcXHRcXHQ8YnIgLz5cXHJcXG5cXHRcXHRcXHRcXHQ8aHIgLz5cXHJcXG5cXHRcXHRcXHRcXHQ8YnIgLz5cXHJcXG5cXHRcXHRcXHRcXHRcXHJcXG5cXHRcXHRcXHRcXHQ8dGFibGUgaWQ9XFxcInN0YXRpc3RpY3NcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDx0Ym9keT5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8dHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHRkPkFJIEFjY3VyYWN5OjwvdGQ+XFx0PHRkPjxzcGFuIGlkPVxcXCJhSUFjY3VyYWN5XFxcIj48L3NwYW4+PC90ZD5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDx0cj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8dGQ+R2FpbiBmcm9tIEFJOjwvdGQ+XFx0PHRkPjxzcGFuIGlkPVxcXCJhSUdhaW5cXFwiPjwvc3Bhbj48L3RkPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDx0ZD5Ob3JtYWxpemVkOjwvdGQ+XFx0PHRkPjxzcGFuIGlkPVxcXCJub3JtYWxpemVkR2FpblxcXCI+PC9zcGFuPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC90cj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L3Rib2R5PlxcclxcblxcdFxcdFxcdFxcdDwvdGFibGU+XFxyXFxuXFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0PGJyIC8+XFxyXFxuXFx0XFx0XFx0PGJyIC8+XFxyXFxuXFx0XFx0XFx0PGJyIC8+XFxyXFxuXFx0XFx0XFx0PGJyIC8+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFx0PCEtLTwvYm9keT5cXHJcXG48L2h0bWw+LS0+XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9pbmRleC5odG1sXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("/****** ABOUT ******\n\nEntry\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2007.07.29\n\tReleased: \n\tDescription: A key-value pair.\n\t\n\n****** ***** ******/\n\n//UNF: below was pasted from StateLearner.js, and I'm still converting it into GroupLearner\n\n/******** CONSTRUCTOR ********/\n\nfunction Entry (key, value)\n{\n\tthis.key = key;\n\tthis.value = value;\n}\n\n\n/******** PROPERTIES ********/\n\nEntry.prototype.key;\nEntry.prototype.value;\n\n\n/******** METHODS ********/\n\nEntry.prototype.clone = function ()\n{\n\treturn new Entry(this.key.clone(), this.value.clone());\n}\n\nEntry.prototype.toString = function ()\n{\n\treturn this.key+\"\\t=>\\t\"+this.value;\n}\n\nmodule.exports = Entry;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9FbnRyeS5qcz8xZDFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiogQUJPVVQgKioqKioqXG5cbkVudHJ5XG5cblx0QXV0aG9yOiBUb20gTGFtYiwgTGFtYnl0ZS5jb21cblx0Q3JlYXRlZDogMjAwNy4wNy4yOVxuXHRSZWxlYXNlZDogXG5cdERlc2NyaXB0aW9uOiBBIGtleS12YWx1ZSBwYWlyLlxuXHRcblxuKioqKioqICoqKioqICoqKioqKi9cblxuLy9VTkY6IGJlbG93IHdhcyBwYXN0ZWQgZnJvbSBTdGF0ZUxlYXJuZXIuanMsIGFuZCBJJ20gc3RpbGwgY29udmVydGluZyBpdCBpbnRvIEdyb3VwTGVhcm5lclxuXG4vKioqKioqKiogQ09OU1RSVUNUT1IgKioqKioqKiovXG5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlKVxue1xuXHR0aGlzLmtleSA9IGtleTtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5cbi8qKioqKioqKiBQUk9QRVJUSUVTICoqKioqKioqL1xuXG5FbnRyeS5wcm90b3R5cGUua2V5O1xuRW50cnkucHJvdG90eXBlLnZhbHVlO1xuXG5cbi8qKioqKioqKiBNRVRIT0RTICoqKioqKioqL1xuXG5FbnRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gbmV3IEVudHJ5KHRoaXMua2V5LmNsb25lKCksIHRoaXMudmFsdWUuY2xvbmUoKSk7XG59XG5cbkVudHJ5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmtleStcIlxcdD0+XFx0XCIrdGhpcy52YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnRyeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RhdGUtbGVhcm5lci9FbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/****** ABOUT ******\n\nIncidenceMap\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2007.08.27\n\tReleased: \n\tDescription: An object which stores the number of times that a value is encountered. The difference between this and a plain map is that .get(index) returns 0 when no entry with that key exists, and this object adds the .increment(key, [times]) function which increments the count of the key the given number of times, or once if times is undefined.\n\t\n\n****** ***** ******/\n\n//try using native Map\t\n//const Map = require(\"./Map.js\");\n\n\n/******* CONSTRUCTOR *******/\n\nfunction IncidenceMap ()\n{\n\tthis._map = new Map();\n\tthis.size = 0;\n}\n\n\n/******* PROPERTIES *******/\n\nIncidenceMap.prototype._map;\nIncidenceMap.prototype.size;\n\n\n/******* METHODS *******/\n\nIncidenceMap.prototype.increment = function (key, times)\n{\n\ttimes = (times == undefined)? 1 : times;\n\tvar count = this.set(key, this.get(key)+times);\n\treturn count;\n}\n\nIncidenceMap.prototype.addMap = function (incidence)\n{\n\tvar result = new IncidenceMap();\n\t\n\tfunction count (entry)\n\t{\n\t\tresult.increment(entry.key, entry.value);\n\t}\n\t\n\tthis.forEach(count);\n\tincidence.forEach(count);\n\t\n\treturn result;\n}\n\nIncidenceMap.prototype.getMaxima = function ()\n{\n\tvar maxima = new Array();\n\tvar maxCount = 0;\n\tthis.forEach(function (entry)\n\t\t{\n\t\t\tif (entry.value > maxCount)\n\t\t\t{\n\t\t\t\tmaxima = new Array();\n\t\t\t\tmaxima.push(entry.key);\n\t\t\t\tmaxCount = entry.value;\n\t\t\t}\n\t\t\telse if (entry.value == maxCount)\n\t\t\t{\n\t\t\t\tmaxima.push(entry.key);\n\t\t\t}\n\t\t});\n\treturn maxima;\n}\n\nIncidenceMap.prototype.get = function (index)\n{\n\tvar count = this._map.get(index);\n\tif (count == undefined)\n\t{\n\t\tcount = 0;\n\t}\n\t\n\treturn count;\n}\n\nIncidenceMap.prototype.set = function (indexName, newValue)\n{\n\tthis._map.set(indexName, newValue);\n\tthis.size = this._map.size;\n\treturn newValue;\n}\n\nIncidenceMap.prototype.contains = function (indexName)\n{\n\treturn this._map.contains(indexName);\n}\n\nIncidenceMap.prototype.forEach = function (f)\n{\n\tthis._map.forEach(f);\n}\n\nIncidenceMap.prototype.clone = function ()\n{\n\tvar emptyMap = new IncidenceMap();\n\tvar spawn = emptyMap.addMap(this._map.clone());\n\t\n\treturn spawn;\n}\n\nIncidenceMap.prototype.toString = function ()\n{\n\treturn this._map.toString();\n}\n\nmodule.exports = IncidenceMap;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9JbmNpZGVuY2VNYXAuanM/MWY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqIEFCT1VUICoqKioqKlxuXG5JbmNpZGVuY2VNYXBcblxuXHRBdXRob3I6IFRvbSBMYW1iLCBMYW1ieXRlLmNvbVxuXHRDcmVhdGVkOiAyMDA3LjA4LjI3XG5cdFJlbGVhc2VkOiBcblx0RGVzY3JpcHRpb246IEFuIG9iamVjdCB3aGljaCBzdG9yZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IGEgdmFsdWUgaXMgZW5jb3VudGVyZWQuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBhbmQgYSBwbGFpbiBtYXAgaXMgdGhhdCAuZ2V0KGluZGV4KSByZXR1cm5zIDAgd2hlbiBubyBlbnRyeSB3aXRoIHRoYXQga2V5IGV4aXN0cywgYW5kIHRoaXMgb2JqZWN0IGFkZHMgdGhlIC5pbmNyZW1lbnQoa2V5LCBbdGltZXNdKSBmdW5jdGlvbiB3aGljaCBpbmNyZW1lbnRzIHRoZSBjb3VudCBvZiB0aGUga2V5IHRoZSBnaXZlbiBudW1iZXIgb2YgdGltZXMsIG9yIG9uY2UgaWYgdGltZXMgaXMgdW5kZWZpbmVkLlxuXHRcblxuKioqKioqICoqKioqICoqKioqKi9cblxuLy90cnkgdXNpbmcgbmF0aXZlIE1hcFx0XG4vL2NvbnN0IE1hcCA9IHJlcXVpcmUoXCIuL01hcC5qc1wiKTtcblxuXG4vKioqKioqKiBDT05TVFJVQ1RPUiAqKioqKioqL1xuXG5mdW5jdGlvbiBJbmNpZGVuY2VNYXAgKClcbntcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXHR0aGlzLnNpemUgPSAwO1xufVxuXG5cbi8qKioqKioqIFBST1BFUlRJRVMgKioqKioqKi9cblxuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5fbWFwO1xuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5zaXplO1xuXG5cbi8qKioqKioqIE1FVEhPRFMgKioqKioqKi9cblxuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbiAoa2V5LCB0aW1lcylcbntcblx0dGltZXMgPSAodGltZXMgPT0gdW5kZWZpbmVkKT8gMSA6IHRpbWVzO1xuXHR2YXIgY291bnQgPSB0aGlzLnNldChrZXksIHRoaXMuZ2V0KGtleSkrdGltZXMpO1xuXHRyZXR1cm4gY291bnQ7XG59XG5cbkluY2lkZW5jZU1hcC5wcm90b3R5cGUuYWRkTWFwID0gZnVuY3Rpb24gKGluY2lkZW5jZSlcbntcblx0dmFyIHJlc3VsdCA9IG5ldyBJbmNpZGVuY2VNYXAoKTtcblx0XG5cdGZ1bmN0aW9uIGNvdW50IChlbnRyeSlcblx0e1xuXHRcdHJlc3VsdC5pbmNyZW1lbnQoZW50cnkua2V5LCBlbnRyeS52YWx1ZSk7XG5cdH1cblx0XG5cdHRoaXMuZm9yRWFjaChjb3VudCk7XG5cdGluY2lkZW5jZS5mb3JFYWNoKGNvdW50KTtcblx0XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbkluY2lkZW5jZU1hcC5wcm90b3R5cGUuZ2V0TWF4aW1hID0gZnVuY3Rpb24gKClcbntcblx0dmFyIG1heGltYSA9IG5ldyBBcnJheSgpO1xuXHR2YXIgbWF4Q291bnQgPSAwO1xuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KVxuXHRcdHtcblx0XHRcdGlmIChlbnRyeS52YWx1ZSA+IG1heENvdW50KVxuXHRcdFx0e1xuXHRcdFx0XHRtYXhpbWEgPSBuZXcgQXJyYXkoKTtcblx0XHRcdFx0bWF4aW1hLnB1c2goZW50cnkua2V5KTtcblx0XHRcdFx0bWF4Q291bnQgPSBlbnRyeS52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGVudHJ5LnZhbHVlID09IG1heENvdW50KVxuXHRcdFx0e1xuXHRcdFx0XHRtYXhpbWEucHVzaChlbnRyeS5rZXkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRyZXR1cm4gbWF4aW1hO1xufVxuXG5JbmNpZGVuY2VNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleClcbntcblx0dmFyIGNvdW50ID0gdGhpcy5fbWFwLmdldChpbmRleCk7XG5cdGlmIChjb3VudCA9PSB1bmRlZmluZWQpXG5cdHtcblx0XHRjb3VudCA9IDA7XG5cdH1cblx0XG5cdHJldHVybiBjb3VudDtcbn1cblxuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lLCBuZXdWYWx1ZSlcbntcblx0dGhpcy5fbWFwLnNldChpbmRleE5hbWUsIG5ld1ZhbHVlKTtcblx0dGhpcy5zaXplID0gdGhpcy5fbWFwLnNpemU7XG5cdHJldHVybiBuZXdWYWx1ZTtcbn1cblxuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChpbmRleE5hbWUpXG57XG5cdHJldHVybiB0aGlzLl9tYXAuY29udGFpbnMoaW5kZXhOYW1lKTtcbn1cblxuSW5jaWRlbmNlTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpXG57XG5cdHRoaXMuX21hcC5mb3JFYWNoKGYpO1xufVxuXG5JbmNpZGVuY2VNYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcblx0dmFyIGVtcHR5TWFwID0gbmV3IEluY2lkZW5jZU1hcCgpO1xuXHR2YXIgc3Bhd24gPSBlbXB0eU1hcC5hZGRNYXAodGhpcy5fbWFwLmNsb25lKCkpO1xuXHRcblx0cmV0dXJuIHNwYXduO1xufVxuXG5JbmNpZGVuY2VNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuX21hcC50b1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluY2lkZW5jZU1hcDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RhdGUtbGVhcm5lci9JbmNpZGVuY2VNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("/****** ABOUT ******\n\nPredictionData\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2007.08.02\n\tReleased: \n\tDescription: An object specifying all the properties of a prediction.\n\t\n\n****** ***** ******/\n\t\n\n/******** CONSTRUCTOR ********/\n\nfunction PredictionData (matchLength, states) \n{\n\tthis.matchLength = matchLength;\n\tthis.states = states || new Array();\n}\n\n\n/******** PROPERTIES ********/\n\n//The longest history match that led to this prediction.\nPredictionData.prototype.matchLength;\n//The predicted state (or states, in which case this is an array of states)\nPredictionData.prototype.states;\n\n\n/******** METHODS ********/\n\nPredictionData.prototype.getIsValid = function ()\n{\n\treturn (this.matchLength != undefined);\n}\n\nmodule.exports = PredictionData;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9QcmVkaWN0aW9uRGF0YS5qcz9kNGQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiogQUJPVVQgKioqKioqXG5cblByZWRpY3Rpb25EYXRhXG5cblx0QXV0aG9yOiBUb20gTGFtYiwgTGFtYnl0ZS5jb21cblx0Q3JlYXRlZDogMjAwNy4wOC4wMlxuXHRSZWxlYXNlZDogXG5cdERlc2NyaXB0aW9uOiBBbiBvYmplY3Qgc3BlY2lmeWluZyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYSBwcmVkaWN0aW9uLlxuXHRcblxuKioqKioqICoqKioqICoqKioqKi9cblx0XG5cbi8qKioqKioqKiBDT05TVFJVQ1RPUiAqKioqKioqKi9cblxuZnVuY3Rpb24gUHJlZGljdGlvbkRhdGEgKG1hdGNoTGVuZ3RoLCBzdGF0ZXMpIFxue1xuXHR0aGlzLm1hdGNoTGVuZ3RoID0gbWF0Y2hMZW5ndGg7XG5cdHRoaXMuc3RhdGVzID0gc3RhdGVzIHx8IG5ldyBBcnJheSgpO1xufVxuXG5cbi8qKioqKioqKiBQUk9QRVJUSUVTICoqKioqKioqL1xuXG4vL1RoZSBsb25nZXN0IGhpc3RvcnkgbWF0Y2ggdGhhdCBsZWQgdG8gdGhpcyBwcmVkaWN0aW9uLlxuUHJlZGljdGlvbkRhdGEucHJvdG90eXBlLm1hdGNoTGVuZ3RoO1xuLy9UaGUgcHJlZGljdGVkIHN0YXRlIChvciBzdGF0ZXMsIGluIHdoaWNoIGNhc2UgdGhpcyBpcyBhbiBhcnJheSBvZiBzdGF0ZXMpXG5QcmVkaWN0aW9uRGF0YS5wcm90b3R5cGUuc3RhdGVzO1xuXG5cbi8qKioqKioqKiBNRVRIT0RTICoqKioqKioqL1xuXG5QcmVkaWN0aW9uRGF0YS5wcm90b3R5cGUuZ2V0SXNWYWxpZCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiAodGhpcy5tYXRjaExlbmd0aCAhPSB1bmRlZmluZWQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZWRpY3Rpb25EYXRhO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdGF0ZS1sZWFybmVyL1ByZWRpY3Rpb25EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n/****** ABOUT ******\n\nStateLearner\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2006.07.13\n\tReleased: \n\tDescription: An object that takes input and stores into history, which it uses to try to predict the next input.\n\t\n\t\n****** ***** ******/\n\nconst ArrayMap = __webpack_require__(0);\nconst PredictionData = __webpack_require__(6);\nconst StateLine = __webpack_require__(8);\n\n\n/******** CONSTRUCTOR ********/\n\nfunction StateLearner (recall)\n{\n\tthis.recall = recall || Infinity;\n\tthis._stateLine = new StateLine();\n}\n\n\n/******** PROPERTIES ********/\n\n//Maximum length for a sequence of states to be stored or retrieved\nStateLearner.prototype.recall;\n//This state learner's state line\nStateLearner.prototype._stateLine;\n\n\n/******** METHODS ********/\n\nStateLearner.prototype.append = function (state)\n{\n\tthis._stateLine.add(state);\n}\n\nStateLearner.prototype.makePrediction = function ()\n{\n\t//???: potentials should really be a set, but I just don't have one made yet. But isn't an array sufficient, even better? I'm pretty sure that direct access to an element of an array would be faster than a getter method on a set object by orders of magnitude.\n\n\tvar historyFragment = this._stateLine.history.slice(0);\n\t//we know we won't be able to find any states that have come after the entire history, start with the second-longest history by removing the most distant state\n\thistoryFragment.shift();\n\t//only search for as much history as this instance can recall. Since the state that is potentially to be found in incidence is counted when counting recall capacity, history fragment can only be recall-1\n\twhile (historyFragment.length > this.recall-1)\n\t{\n\t\thistoryFragment.shift();\n\t}\n\t\n\tvar potentials = new Array();\n\tvar predictionData = new PredictionData();\n\twhile (historyFragment.length >= 0)\n\t{\n\t\t//at the end of each round, if there is only one potential state, that means that all other potential states have been eliminated in previous iterations, so we return that. As a result, if at the beginning of an iteration, potentials is non-empty, that means that there must have been more than one left at the end of the last iteration. When there is more than one left, that means there was a tie at the end of the last iteration, so we settle that by finding a maximum among potentials in the incidence of this iteration. If potentials is empty, however, we fill it with the maxima of incidence. If we fill potentials with all of incidence when it is empty, we can use the same algorithm when potentials is empty as when it is non-empty.\n\t\tvar incidence = this._stateLine.incidenceFollowing(historyFragment);\n\n\t\tif (potentials.length == 0)\n\t\t{\n\t\t\tincidence.forEach(function (value, key) {\n\t\t\t\tpotentials.push(key);\n\t\t\t});\n\t\t\t\n\t\t\tif (potentials.length >= 1) predictionData.matchLength = historyFragment.length;\n\t\t}\n\t\tvar max = 0;\n\t\tvar newPotentials = new Array();\n\t\tfor (var i = 0; i <= potentials.length-1; i++)\n\t\t{\n\t\t\tvar currentState = potentials[i];\n\t\t\tvar stateCount = incidence.get(currentState);\n\t\t\tif (stateCount > max)\n\t\t\t{\n\t\t\t\tmax = stateCount;\n\t\t\t\tnewPotentials = new Array();\n\t\t\t\tnewPotentials.push(currentState);\n\t\t\t}\n\t\t\telse if (stateCount == max)\n\t\t\t{\n\t\t\t\tnewPotentials.push(currentState);\n\t\t\t}\n\t\t}\n\t\tpotentials = newPotentials;\n\n\t\tif (potentials.length == 1)\n\t\t{\n\t\t\tpredictionData.states = potentials;\n\t\t\treturn predictionData;\n\t\t}\n\t\telse if (historyFragment.length == 0)\n\t\t{\n\t\t\tif (potentials.length == 0)\n\t\t\t{\n\t\t\t\t//because all history including null history has been checked for a match and potentials is still empty, we can infer that there was never any input to begin with.\n\t\t\t\t\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//since there hasn't been a solitary maximum found at any level of detail, and the list of potentials is non-empty, we know that there must be a tie between two or more states. By returning the potentials array, the user can choose what to do with the all the relevant information available.\n\t\t\t\tpredictionData.states = potentials;\n\t\t\t\treturn predictionData;\n\t\t\t}\n\t\t}\n\t\t\n\t\thistoryFragment.shift();\n\t}\n\t\n\t//recall is 0, so it's impossible to predict anything\n\treturn undefined;\n}\n\nmodule.exports = StateLearner;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9TdGF0ZUxlYXJuZXIuanM/YjI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuLyoqKioqKiBBQk9VVCAqKioqKipcblxuU3RhdGVMZWFybmVyXG5cblx0QXV0aG9yOiBUb20gTGFtYiwgTGFtYnl0ZS5jb21cblx0Q3JlYXRlZDogMjAwNi4wNy4xM1xuXHRSZWxlYXNlZDogXG5cdERlc2NyaXB0aW9uOiBBbiBvYmplY3QgdGhhdCB0YWtlcyBpbnB1dCBhbmQgc3RvcmVzIGludG8gaGlzdG9yeSwgd2hpY2ggaXQgdXNlcyB0byB0cnkgdG8gcHJlZGljdCB0aGUgbmV4dCBpbnB1dC5cblx0XG5cdFxuKioqKioqICoqKioqICoqKioqKi9cblxuY29uc3QgQXJyYXlNYXAgPSByZXF1aXJlKFwiLi9BcnJheU1hcC5qc1wiKTtcbmNvbnN0IFByZWRpY3Rpb25EYXRhID0gcmVxdWlyZShcIi4vUHJlZGljdGlvbkRhdGEuanNcIik7XG5jb25zdCBTdGF0ZUxpbmUgPSByZXF1aXJlKFwiLi9TdGF0ZUxpbmUuanNcIik7XG5cblxuLyoqKioqKioqIENPTlNUUlVDVE9SICoqKioqKioqL1xuXG5mdW5jdGlvbiBTdGF0ZUxlYXJuZXIgKHJlY2FsbClcbntcblx0dGhpcy5yZWNhbGwgPSByZWNhbGwgfHwgSW5maW5pdHk7XG5cdHRoaXMuX3N0YXRlTGluZSA9IG5ldyBTdGF0ZUxpbmUoKTtcbn1cblxuXG4vKioqKioqKiogUFJPUEVSVElFUyAqKioqKioqKi9cblxuLy9NYXhpbXVtIGxlbmd0aCBmb3IgYSBzZXF1ZW5jZSBvZiBzdGF0ZXMgdG8gYmUgc3RvcmVkIG9yIHJldHJpZXZlZFxuU3RhdGVMZWFybmVyLnByb3RvdHlwZS5yZWNhbGw7XG4vL1RoaXMgc3RhdGUgbGVhcm5lcidzIHN0YXRlIGxpbmVcblN0YXRlTGVhcm5lci5wcm90b3R5cGUuX3N0YXRlTGluZTtcblxuXG4vKioqKioqKiogTUVUSE9EUyAqKioqKioqKi9cblxuU3RhdGVMZWFybmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoc3RhdGUpXG57XG5cdHRoaXMuX3N0YXRlTGluZS5hZGQoc3RhdGUpO1xufVxuXG5TdGF0ZUxlYXJuZXIucHJvdG90eXBlLm1ha2VQcmVkaWN0aW9uID0gZnVuY3Rpb24gKClcbntcblx0Ly8/Pz86IHBvdGVudGlhbHMgc2hvdWxkIHJlYWxseSBiZSBhIHNldCwgYnV0IEkganVzdCBkb24ndCBoYXZlIG9uZSBtYWRlIHlldC4gQnV0IGlzbid0IGFuIGFycmF5IHN1ZmZpY2llbnQsIGV2ZW4gYmV0dGVyPyBJJ20gcHJldHR5IHN1cmUgdGhhdCBkaXJlY3QgYWNjZXNzIHRvIGFuIGVsZW1lbnQgb2YgYW4gYXJyYXkgd291bGQgYmUgZmFzdGVyIHRoYW4gYSBnZXR0ZXIgbWV0aG9kIG9uIGEgc2V0IG9iamVjdCBieSBvcmRlcnMgb2YgbWFnbml0dWRlLlxuXG5cdHZhciBoaXN0b3J5RnJhZ21lbnQgPSB0aGlzLl9zdGF0ZUxpbmUuaGlzdG9yeS5zbGljZSgwKTtcblx0Ly93ZSBrbm93IHdlIHdvbid0IGJlIGFibGUgdG8gZmluZCBhbnkgc3RhdGVzIHRoYXQgaGF2ZSBjb21lIGFmdGVyIHRoZSBlbnRpcmUgaGlzdG9yeSwgc3RhcnQgd2l0aCB0aGUgc2Vjb25kLWxvbmdlc3QgaGlzdG9yeSBieSByZW1vdmluZyB0aGUgbW9zdCBkaXN0YW50IHN0YXRlXG5cdGhpc3RvcnlGcmFnbWVudC5zaGlmdCgpO1xuXHQvL29ubHkgc2VhcmNoIGZvciBhcyBtdWNoIGhpc3RvcnkgYXMgdGhpcyBpbnN0YW5jZSBjYW4gcmVjYWxsLiBTaW5jZSB0aGUgc3RhdGUgdGhhdCBpcyBwb3RlbnRpYWxseSB0byBiZSBmb3VuZCBpbiBpbmNpZGVuY2UgaXMgY291bnRlZCB3aGVuIGNvdW50aW5nIHJlY2FsbCBjYXBhY2l0eSwgaGlzdG9yeSBmcmFnbWVudCBjYW4gb25seSBiZSByZWNhbGwtMVxuXHR3aGlsZSAoaGlzdG9yeUZyYWdtZW50Lmxlbmd0aCA+IHRoaXMucmVjYWxsLTEpXG5cdHtcblx0XHRoaXN0b3J5RnJhZ21lbnQuc2hpZnQoKTtcblx0fVxuXHRcblx0dmFyIHBvdGVudGlhbHMgPSBuZXcgQXJyYXkoKTtcblx0dmFyIHByZWRpY3Rpb25EYXRhID0gbmV3IFByZWRpY3Rpb25EYXRhKCk7XG5cdHdoaWxlIChoaXN0b3J5RnJhZ21lbnQubGVuZ3RoID49IDApXG5cdHtcblx0XHQvL2F0IHRoZSBlbmQgb2YgZWFjaCByb3VuZCwgaWYgdGhlcmUgaXMgb25seSBvbmUgcG90ZW50aWFsIHN0YXRlLCB0aGF0IG1lYW5zIHRoYXQgYWxsIG90aGVyIHBvdGVudGlhbCBzdGF0ZXMgaGF2ZSBiZWVuIGVsaW1pbmF0ZWQgaW4gcHJldmlvdXMgaXRlcmF0aW9ucywgc28gd2UgcmV0dXJuIHRoYXQuIEFzIGEgcmVzdWx0LCBpZiBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGl0ZXJhdGlvbiwgcG90ZW50aWFscyBpcyBub24tZW1wdHksIHRoYXQgbWVhbnMgdGhhdCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBtb3JlIHRoYW4gb25lIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBpdGVyYXRpb24uIFdoZW4gdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBsZWZ0LCB0aGF0IG1lYW5zIHRoZXJlIHdhcyBhIHRpZSBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGl0ZXJhdGlvbiwgc28gd2Ugc2V0dGxlIHRoYXQgYnkgZmluZGluZyBhIG1heGltdW0gYW1vbmcgcG90ZW50aWFscyBpbiB0aGUgaW5jaWRlbmNlIG9mIHRoaXMgaXRlcmF0aW9uLiBJZiBwb3RlbnRpYWxzIGlzIGVtcHR5LCBob3dldmVyLCB3ZSBmaWxsIGl0IHdpdGggdGhlIG1heGltYSBvZiBpbmNpZGVuY2UuIElmIHdlIGZpbGwgcG90ZW50aWFscyB3aXRoIGFsbCBvZiBpbmNpZGVuY2Ugd2hlbiBpdCBpcyBlbXB0eSwgd2UgY2FuIHVzZSB0aGUgc2FtZSBhbGdvcml0aG0gd2hlbiBwb3RlbnRpYWxzIGlzIGVtcHR5IGFzIHdoZW4gaXQgaXMgbm9uLWVtcHR5LlxuXHRcdHZhciBpbmNpZGVuY2UgPSB0aGlzLl9zdGF0ZUxpbmUuaW5jaWRlbmNlRm9sbG93aW5nKGhpc3RvcnlGcmFnbWVudCk7XG5cblx0XHRpZiAocG90ZW50aWFscy5sZW5ndGggPT0gMClcblx0XHR7XG5cdFx0XHRpbmNpZGVuY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRwb3RlbnRpYWxzLnB1c2goa2V5KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAocG90ZW50aWFscy5sZW5ndGggPj0gMSkgcHJlZGljdGlvbkRhdGEubWF0Y2hMZW5ndGggPSBoaXN0b3J5RnJhZ21lbnQubGVuZ3RoO1xuXHRcdH1cblx0XHR2YXIgbWF4ID0gMDtcblx0XHR2YXIgbmV3UG90ZW50aWFscyA9IG5ldyBBcnJheSgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IHBvdGVudGlhbHMubGVuZ3RoLTE7IGkrKylcblx0XHR7XG5cdFx0XHR2YXIgY3VycmVudFN0YXRlID0gcG90ZW50aWFsc1tpXTtcblx0XHRcdHZhciBzdGF0ZUNvdW50ID0gaW5jaWRlbmNlLmdldChjdXJyZW50U3RhdGUpO1xuXHRcdFx0aWYgKHN0YXRlQ291bnQgPiBtYXgpXG5cdFx0XHR7XG5cdFx0XHRcdG1heCA9IHN0YXRlQ291bnQ7XG5cdFx0XHRcdG5ld1BvdGVudGlhbHMgPSBuZXcgQXJyYXkoKTtcblx0XHRcdFx0bmV3UG90ZW50aWFscy5wdXNoKGN1cnJlbnRTdGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzdGF0ZUNvdW50ID09IG1heClcblx0XHRcdHtcblx0XHRcdFx0bmV3UG90ZW50aWFscy5wdXNoKGN1cnJlbnRTdGF0ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHBvdGVudGlhbHMgPSBuZXdQb3RlbnRpYWxzO1xuXG5cdFx0aWYgKHBvdGVudGlhbHMubGVuZ3RoID09IDEpXG5cdFx0e1xuXHRcdFx0cHJlZGljdGlvbkRhdGEuc3RhdGVzID0gcG90ZW50aWFscztcblx0XHRcdHJldHVybiBwcmVkaWN0aW9uRGF0YTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoaGlzdG9yeUZyYWdtZW50Lmxlbmd0aCA9PSAwKVxuXHRcdHtcblx0XHRcdGlmIChwb3RlbnRpYWxzLmxlbmd0aCA9PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvL2JlY2F1c2UgYWxsIGhpc3RvcnkgaW5jbHVkaW5nIG51bGwgaGlzdG9yeSBoYXMgYmVlbiBjaGVja2VkIGZvciBhIG1hdGNoIGFuZCBwb3RlbnRpYWxzIGlzIHN0aWxsIGVtcHR5LCB3ZSBjYW4gaW5mZXIgdGhhdCB0aGVyZSB3YXMgbmV2ZXIgYW55IGlucHV0IHRvIGJlZ2luIHdpdGguXG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQvL3NpbmNlIHRoZXJlIGhhc24ndCBiZWVuIGEgc29saXRhcnkgbWF4aW11bSBmb3VuZCBhdCBhbnkgbGV2ZWwgb2YgZGV0YWlsLCBhbmQgdGhlIGxpc3Qgb2YgcG90ZW50aWFscyBpcyBub24tZW1wdHksIHdlIGtub3cgdGhhdCB0aGVyZSBtdXN0IGJlIGEgdGllIGJldHdlZW4gdHdvIG9yIG1vcmUgc3RhdGVzLiBCeSByZXR1cm5pbmcgdGhlIHBvdGVudGlhbHMgYXJyYXksIHRoZSB1c2VyIGNhbiBjaG9vc2Ugd2hhdCB0byBkbyB3aXRoIHRoZSBhbGwgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGF2YWlsYWJsZS5cblx0XHRcdFx0cHJlZGljdGlvbkRhdGEuc3RhdGVzID0gcG90ZW50aWFscztcblx0XHRcdFx0cmV0dXJuIHByZWRpY3Rpb25EYXRhO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRoaXN0b3J5RnJhZ21lbnQuc2hpZnQoKTtcblx0fVxuXHRcblx0Ly9yZWNhbGwgaXMgMCwgc28gaXQncyBpbXBvc3NpYmxlIHRvIHByZWRpY3QgYW55dGhpbmdcblx0cmV0dXJuIHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUxlYXJuZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0YXRlLWxlYXJuZXIvU3RhdGVMZWFybmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("/****** ABOUT ******\n\nStateLine\n\n\tAuthor: Tom Lamb, Lambyte.com\n\tCreated: 2007.08.25\n\tReleased: \n\tDescription: An object that stores a sequence of states and can return the incidence of which states follow given state sequences.\n\t\n\t\n\n****** ***** ******/\n\nconst ArrayMap = __webpack_require__(0);\nconst IncidenceMap = __webpack_require__(5);\n\n\n/******** CONSTRUCTOR ********/\n\nfunction StateLine ()\n{\n\tthis.history = new Array();\n\tthis._ledger = new ArrayMap();\n}\n\n\n/******** PROPERTIES ********/\n\n//Structure of history: history[n] = input of the nth turn*/\nStateLine.prototype.history;\n//Structure of ledger: ledger.get(history fragment) => incidence.get(state N) = number of times that state N occurs after the given \"history fragment\"\nStateLine.prototype._ledger;\n\n\n/******** METHODS ********/\n\nStateLine.prototype.add = function (state)\n{\n\tvar historyFragment = this.history.slice(0);\n\t\n\twhile (true)\n\t{\n\t\t//increment the incidence count for the number of times that \"historyFragment\" has preceded \"state\"\n\t\tvar incidence = this._ledger.get(historyFragment);\n\t\t\n\t\tif (incidence == undefined)\n\t\t{\n\t\t\t//this history fragment has not occurred yet, so create a new incidence map\n\t\t\tvar newIncidence = new IncidenceMap();\n\t\t\tnewIncidence.set(state, 1);\n\t\t\t//NOTE: We have to clone historyFragment, because we are creating a new entry in the map. If it were left uncloned, we might modify the array being used for the purposes of this loop, and at the same time modify the array being used as an index in the map.\n\t\t\tthis._ledger.set(historyFragment.slice(0), newIncidence);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tincidence.increment(state);\n\t\t\t//incidence is an object, and therefore a reference, so we don't need to call ledger.set(historyFragment, incidence)\n\t\t}\n\t\t\n\t\tif (historyFragment.length == 0)\n\t\t{\n\t\t\tthis.history.push(state);\n\t\t\treturn;\n\t\t}\n\t\thistoryFragment.shift();\n\t}\n\t\n}\n\nStateLine.prototype.incidenceFollowing = function (sequence)\n{\n\t//NOTE: sequence should be an array\n\tvar incidence = this._ledger.get(sequence);\n\tif (incidence == undefined)\n\t{\n\t\treturn new IncidenceMap();\n\t}\n\telse\n\t{\n\t\treturn incidence;\n\t}\n}\n\nmodule.exports = StateLine;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3RhdGUtbGVhcm5lci9TdGF0ZUxpbmUuanM/ZmYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqIEFCT1VUICoqKioqKlxuXG5TdGF0ZUxpbmVcblxuXHRBdXRob3I6IFRvbSBMYW1iLCBMYW1ieXRlLmNvbVxuXHRDcmVhdGVkOiAyMDA3LjA4LjI1XG5cdFJlbGVhc2VkOiBcblx0RGVzY3JpcHRpb246IEFuIG9iamVjdCB0aGF0IHN0b3JlcyBhIHNlcXVlbmNlIG9mIHN0YXRlcyBhbmQgY2FuIHJldHVybiB0aGUgaW5jaWRlbmNlIG9mIHdoaWNoIHN0YXRlcyBmb2xsb3cgZ2l2ZW4gc3RhdGUgc2VxdWVuY2VzLlxuXHRcblx0XG5cbioqKioqKiAqKioqKiAqKioqKiovXG5cbmNvbnN0IEFycmF5TWFwID0gcmVxdWlyZShcIi4vQXJyYXlNYXAuanNcIik7XG5jb25zdCBJbmNpZGVuY2VNYXAgPSByZXF1aXJlKFwiLi9JbmNpZGVuY2VNYXAuanNcIik7XG5cblxuLyoqKioqKioqIENPTlNUUlVDVE9SICoqKioqKioqL1xuXG5mdW5jdGlvbiBTdGF0ZUxpbmUgKClcbntcblx0dGhpcy5oaXN0b3J5ID0gbmV3IEFycmF5KCk7XG5cdHRoaXMuX2xlZGdlciA9IG5ldyBBcnJheU1hcCgpO1xufVxuXG5cbi8qKioqKioqKiBQUk9QRVJUSUVTICoqKioqKioqL1xuXG4vL1N0cnVjdHVyZSBvZiBoaXN0b3J5OiBoaXN0b3J5W25dID0gaW5wdXQgb2YgdGhlIG50aCB0dXJuKi9cblN0YXRlTGluZS5wcm90b3R5cGUuaGlzdG9yeTtcbi8vU3RydWN0dXJlIG9mIGxlZGdlcjogbGVkZ2VyLmdldChoaXN0b3J5IGZyYWdtZW50KSA9PiBpbmNpZGVuY2UuZ2V0KHN0YXRlIE4pID0gbnVtYmVyIG9mIHRpbWVzIHRoYXQgc3RhdGUgTiBvY2N1cnMgYWZ0ZXIgdGhlIGdpdmVuIFwiaGlzdG9yeSBmcmFnbWVudFwiXG5TdGF0ZUxpbmUucHJvdG90eXBlLl9sZWRnZXI7XG5cblxuLyoqKioqKioqIE1FVEhPRFMgKioqKioqKiovXG5cblN0YXRlTGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHN0YXRlKVxue1xuXHR2YXIgaGlzdG9yeUZyYWdtZW50ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDApO1xuXHRcblx0d2hpbGUgKHRydWUpXG5cdHtcblx0XHQvL2luY3JlbWVudCB0aGUgaW5jaWRlbmNlIGNvdW50IGZvciB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgXCJoaXN0b3J5RnJhZ21lbnRcIiBoYXMgcHJlY2VkZWQgXCJzdGF0ZVwiXG5cdFx0dmFyIGluY2lkZW5jZSA9IHRoaXMuX2xlZGdlci5nZXQoaGlzdG9yeUZyYWdtZW50KTtcblx0XHRcblx0XHRpZiAoaW5jaWRlbmNlID09IHVuZGVmaW5lZClcblx0XHR7XG5cdFx0XHQvL3RoaXMgaGlzdG9yeSBmcmFnbWVudCBoYXMgbm90IG9jY3VycmVkIHlldCwgc28gY3JlYXRlIGEgbmV3IGluY2lkZW5jZSBtYXBcblx0XHRcdHZhciBuZXdJbmNpZGVuY2UgPSBuZXcgSW5jaWRlbmNlTWFwKCk7XG5cdFx0XHRuZXdJbmNpZGVuY2Uuc2V0KHN0YXRlLCAxKTtcblx0XHRcdC8vTk9URTogV2UgaGF2ZSB0byBjbG9uZSBoaXN0b3J5RnJhZ21lbnQsIGJlY2F1c2Ugd2UgYXJlIGNyZWF0aW5nIGEgbmV3IGVudHJ5IGluIHRoZSBtYXAuIElmIGl0IHdlcmUgbGVmdCB1bmNsb25lZCwgd2UgbWlnaHQgbW9kaWZ5IHRoZSBhcnJheSBiZWluZyB1c2VkIGZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBsb29wLCBhbmQgYXQgdGhlIHNhbWUgdGltZSBtb2RpZnkgdGhlIGFycmF5IGJlaW5nIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlIG1hcC5cblx0XHRcdHRoaXMuX2xlZGdlci5zZXQoaGlzdG9yeUZyYWdtZW50LnNsaWNlKDApLCBuZXdJbmNpZGVuY2UpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0aW5jaWRlbmNlLmluY3JlbWVudChzdGF0ZSk7XG5cdFx0XHQvL2luY2lkZW5jZSBpcyBhbiBvYmplY3QsIGFuZCB0aGVyZWZvcmUgYSByZWZlcmVuY2UsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbCBsZWRnZXIuc2V0KGhpc3RvcnlGcmFnbWVudCwgaW5jaWRlbmNlKVxuXHRcdH1cblx0XHRcblx0XHRpZiAoaGlzdG9yeUZyYWdtZW50Lmxlbmd0aCA9PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMuaGlzdG9yeS5wdXNoKHN0YXRlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aGlzdG9yeUZyYWdtZW50LnNoaWZ0KCk7XG5cdH1cblx0XG59XG5cblN0YXRlTGluZS5wcm90b3R5cGUuaW5jaWRlbmNlRm9sbG93aW5nID0gZnVuY3Rpb24gKHNlcXVlbmNlKVxue1xuXHQvL05PVEU6IHNlcXVlbmNlIHNob3VsZCBiZSBhbiBhcnJheVxuXHR2YXIgaW5jaWRlbmNlID0gdGhpcy5fbGVkZ2VyLmdldChzZXF1ZW5jZSk7XG5cdGlmIChpbmNpZGVuY2UgPT0gdW5kZWZpbmVkKVxuXHR7XG5cdFx0cmV0dXJuIG5ldyBJbmNpZGVuY2VNYXAoKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRyZXR1cm4gaW5jaWRlbmNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdGF0ZS1sZWFybmVyL1N0YXRlTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);